<?php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Str;
use App\Models\Mention;
use App\Models\MatchModel;
use App\Events\MatchHeroUpdated;

class MatchController extends Controller
{
    public function index(Request $request)
    {
        try {
            $query = DB::table('matches as m')
                ->leftJoin('teams as t1', 'm.team1_id', '=', 't1.id')
                ->leftJoin('teams as t2', 'm.team2_id', '=', 't2.id')
                ->leftJoin('events as e', 'm.event_id', '=', 'e.id')
                ->select([
                    'm.*',
                    't1.id as team1_id', 't1.name as team1_name', 't1.short_name as team1_short',
                    't1.logo as team1_logo', 't1.region as team1_region', 't1.rating as team1_rating',
                    't2.id as team2_id', 't2.name as team2_name', 't2.short_name as team2_short', 
                    't2.logo as team2_logo', 't2.region as team2_region', 't2.rating as team2_rating',
                    'e.id as event_id', 'e.name as event_name', 'e.type as event_type',
                    'e.logo as event_logo', 'e.region as event_region'
                ]);

            // Status filter
            if ($request->status && $request->status !== 'all') {
                $query->where('m.status', $request->status);
            }

            // Date filter
            if ($request->date) {
                $query->whereDate('m.scheduled_at', $request->date);
            }

            // Event filter
            if ($request->event_id) {
                $query->where('m.event_id', $request->event_id);
            }

            $matches = $query->orderBy('m.scheduled_at', 'desc')->paginate(20);

            // Transform matches with VLR.gg style
            $formattedMatches = collect($matches->items())->map(function($match) {
                return $this->formatMatchData($match);
            });

            // If no matches, return empty array
            if ($formattedMatches->isEmpty()) {
                $formattedMatches = collect([]);
            }

            return response()->json([
                'data' => $formattedMatches,
                'pagination' => [
                    'current_page' => $matches->currentPage(),
                    'last_page' => $matches->lastPage(),
                    'per_page' => $matches->perPage(),
                    'total' => $matches->total()
                ],
                'success' => true
            ]);

        } catch (\Exception $e) {
            \Log::error('MatchController@index error: ' . $e->getMessage() . ' at ' . $e->getFile() . ':' . $e->getLine());
            return response()->json([
                'success' => false,
                'message' => 'Error fetching matches: ' . $e->getMessage(),
                'error_details' => [
                    'file' => $e->getFile(),
                    'line' => $e->getLine(),
                    'trace' => $e->getTraceAsString()
                ]
            ], 500);
        }
    }

    public function show($matchId)
    {
        try {
            $match = DB::table('matches as m')
                ->leftJoin('teams as t1', 'm.team1_id', '=', 't1.id')
                ->leftJoin('teams as t2', 'm.team2_id', '=', 't2.id')
                ->leftJoin('events as e', 'm.event_id', '=', 'e.id')
                ->where('m.id', $matchId)
                ->select([
                    'm.*',
                    't1.id as team1_id', 't1.name as team1_name', 't1.short_name as team1_short',
                    't1.logo as team1_logo', 't1.region as team1_region', 't1.rating as team1_rating',
                    't2.id as team2_id', 't2.name as team2_name', 't2.short_name as team2_short', 
                    't2.logo as team2_logo', 't2.region as team2_region', 't2.rating as team2_rating',
                    'e.id as event_id', 'e.name as event_name', 'e.type as event_type',
                    'e.logo as event_logo', 'e.format as event_format'
                ])
                ->first();

            if (!$match) {
                return response()->json([
                    'success' => false,
                    'message' => 'Match not found'
                ], 404);
            }

            // Get complete match data including players, stats, maps
            $matchData = $this->getCompleteMatchData($match);

            // Get comments with user flairs and avatars
            $comments = $this->getMatchComments($matchId);

            // Increment view count
            DB::table('matches')->where('id', $matchId)->increment('viewers');

            // Return data in the format expected by frontend
            return response()->json(array_merge(
                ['success' => true],
                ['data' => $matchData],
                $matchData,
                ['comments' => $comments]
            ));

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error fetching match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function live(Request $request)
    {
        try {
            $liveMatches = DB::table('matches as m')
                ->leftJoin('teams as t1', 'm.team1_id', '=', 't1.id')
                ->leftJoin('teams as t2', 'm.team2_id', '=', 't2.id')
                ->leftJoin('events as e', 'm.event_id', '=', 'e.id')
                ->where('m.status', 'live')
                ->select([
                    'm.*',
                    't1.name as team1_name', 't1.short_name as team1_short', 't1.logo as team1_logo',
                    't1.region as team1_region', 't1.rating as team1_rating',
                    't2.name as team2_name', 't2.short_name as team2_short', 't2.logo as team2_logo',
                    't2.region as team2_region', 't2.rating as team2_rating',
                    'e.name as event_name', 'e.logo as event_logo'
                ])
                ->orderBy('m.viewers', 'desc')
                ->limit(20)
                ->get();

            $formattedMatches = $liveMatches->map(function($match) {
                return $this->formatMatchData($match, true);
            });

            return response()->json([
                'data' => $formattedMatches,
                'total' => $formattedMatches->count(),
                'success' => true
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error fetching live matches: ' . $e->getMessage()
            ], 500);
        }
    }

    // Admin/Moderator Functions
    public function store(Request $request)
    {
        // Temporarily disable authorization check
        // $this->authorize('create-matches');
        
        $request->validate([
            'team1_id' => 'required|exists:teams,id',
            'team2_id' => 'required|exists:teams,id|different:team1_id',
            'event_id' => 'nullable|exists:events,id',
            'scheduled_at' => 'required|date',
            'format' => 'required|in:BO1,BO3,BO5,BO7,BO9',
            'maps_data' => 'required|array|min:1',
            'maps_data.*.map_name' => 'required|string',
            'maps_data.*.mode' => 'required|string',
            
            // Multiple URLs support
            'stream_urls' => 'nullable|array',
            'stream_urls.*' => 'url',
            'betting_urls' => 'nullable|array',
            'betting_urls.*' => 'url',
            'vod_urls' => 'nullable|array',
            'vod_urls.*' => 'url',
            
            // Tournament context
            'round' => 'nullable|string',
            'bracket_position' => 'nullable|string',
            
            // Administrative
            'allow_past_date' => 'boolean'
        ]);

        try {
            // Validate date for past matches
            if (!$request->allow_past_date && now()->gt($request->scheduled_at)) {
                return response()->json([
                    'success' => false,
                    'message' => 'Cannot schedule matches in the past unless specifically allowed'
                ], 400);
            }

            // Create match
            $matchId = DB::table('matches')->insertGetId([
                'team1_id' => $request->team1_id,
                'team2_id' => $request->team2_id,
                'event_id' => $request->event_id,
                'scheduled_at' => \Carbon\Carbon::parse($request->scheduled_at)->format('Y-m-d H:i:s'),
                'format' => $request->format,
                'status' => 'upcoming',
                'team1_score' => 0,
                'team2_score' => 0,
                'series_score_team1' => 0,
                'series_score_team2' => 0,
                'current_map_number' => 1,
                'viewers' => 0,
                
                // Multiple URLs support
                'stream_urls' => json_encode($request->stream_urls ?? []),
                'betting_urls' => json_encode($request->betting_urls ?? []),
                'vod_urls' => json_encode($request->vod_urls ?? []),
                
                // Tournament context
                'round' => $request->round ?: 'Regular Season',
                'bracket_position' => $request->bracket_position ?: 1,
                
                // Match data
                'maps_data' => json_encode($this->initializeMapsData($request->maps_data, $request->format)),
                'hero_data' => json_encode($this->initializeHeroData($request->format)),
                'live_data' => json_encode($this->initializeLiveData()),
                'player_stats' => json_encode($this->initializePlayerStats($request->team1_id, $request->team2_id)),
                'match_timer' => json_encode(['current_time' => 0, 'phase' => 'preparation']),
                'overtime' => false,
                
                // Administrative
                'created_by' => Auth::id(),
                'allow_past_date' => $request->allow_past_date ?? false,
                'created_at' => now(),
                'updated_at' => now()
            ]);

            return response()->json([
                'data' => ['id' => $matchId],
                'success' => true,
                'message' => 'Match created successfully'
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error creating match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function update(Request $request, $matchId)
    {
        $this->authorize('manage-matches');
        
        $request->validate([
            'team1_id' => 'sometimes|exists:teams,id',
            'team2_id' => 'sometimes|exists:teams,id',
            'event_id' => 'nullable|exists:events,id',
            'scheduled_at' => 'sometimes|date',
            'format' => 'sometimes|in:bo1,bo3,bo5,bo7,bo9',
            'maps' => 'sometimes|array|min:1',
            'stream_url' => 'nullable|url',
            'round' => 'nullable|string',
            'bracket_position' => 'nullable|string'
        ]);

        try {
            $updateData = [];
            
            // Only update provided fields
            $fields = ['team1_id', 'team2_id', 'event_id', 'scheduled_at', 'format', 
                      'stream_url', 'round', 'bracket_position'];
            
            foreach ($fields as $field) {
                if ($request->has($field)) {
                    $updateData[$field] = $request->$field;
                }
            }
            
            // Update maps data if provided
            if ($request->has('maps_data')) {
                $updateData['maps_data'] = json_encode($this->initializeMapsData($request->maps_data));
            }
            
            $updateData['updated_at'] = now();
            
            DB::table('matches')
                ->where('id', $matchId)
                ->update($updateData);

            return response()->json([
                'success' => true,
                'message' => 'Match updated successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error updating match: ' . $e->getMessage()
            ], 500);
        }
    }

    // Live Scoring Functions for Admin/Moderator
    public function setMatchLive(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        try {
            DB::table('matches')
                ->where('id', $matchId)
                ->update([
                    'status' => 'live',
                    'started_at' => now(),
                    'updated_at' => now()
                ]);

            // Initialize first map timer
            $this->startMapTimer($matchId, 1);

            return response()->json([
                'success' => true,
                'message' => 'Match is now live'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error setting match live: ' . $e->getMessage()
            ], 500);
        }
    }

    public function updateLiveData(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        $request->validate([
            'type' => 'required|in:score,timer,map_transition,player_stats,hero_update',
            'data' => 'required|array'
        ]);

        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json(['success' => false, 'message' => 'Match not found'], 404);
            }

            $liveData = json_decode($match->live_data, true);
            $mapsData = json_decode($match->maps_data, true);

            switch ($request->type) {
                case 'score':
                    // Update map score
                    $mapIndex = $request->data['map_index'] ?? ($match->current_map - 1);
                    $mapsData[$mapIndex]['team1_score'] = $request->data['team1_score'];
                    $mapsData[$mapIndex]['team2_score'] = $request->data['team2_score'];
                    $mapsData[$mapIndex]['status'] = $request->data['map_status'] ?? 'ongoing';
                    
                    // Check if map completed
                    if ($request->data['map_status'] === 'completed') {
                        $this->handleMapCompletion($matchId, $mapIndex, $mapsData);
                    }
                    break;

                case 'timer':
                    // Update map timer
                    $liveData['current_map_time'] = $request->data['time'];
                    $liveData['timer_status'] = $request->data['status'] ?? 'running';
                    break;

                case 'map_transition':
                    // Transition to next map
                    $nextMap = $match->current_map + 1;
                    DB::table('matches')->where('id', $matchId)->update([
                        'current_map' => $nextMap
                    ]);
                    $this->startMapTimer($matchId, $nextMap);
                    break;

                case 'player_stats':
                    // Update player stats for current map
                    $this->updatePlayerStats($matchId, $request->data);
                    break;

                case 'hero_update':
                    // Update hero selections for current map
                    $mapIndex = $match->current_map - 1;
                    $mapsData[$mapIndex]['team1_heroes'] = $request->data['team1_heroes'] ?? [];
                    $mapsData[$mapIndex]['team2_heroes'] = $request->data['team2_heroes'] ?? [];
                    break;
            }

            // Update match data
            DB::table('matches')->where('id', $matchId)->update([
                'live_data' => json_encode($liveData),
                'maps_data' => json_encode($mapsData),
                'updated_at' => now()
            ]);

            // Calculate and update overall match score
            $this->updateOverallScore($matchId);

            return response()->json([
                'success' => true,
                'message' => 'Live data updated successfully',
                'data' => [
                    'live_data' => $liveData,
                    'maps_data' => $mapsData
                ]
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error updating live data: ' . $e->getMessage()
            ], 500);
        }
    }

    public function updateMatchScore(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        $request->validate([
            'team1_score' => 'required|integer|min:0',
            'team2_score' => 'required|integer|min:0'
        ]);

        try {
            DB::table('matches')
                ->where('id', $matchId)
                ->update([
                    'team1_score' => $request->team1_score,
                    'team2_score' => $request->team2_score,
                    'updated_at' => now()
                ]);

            return response()->json([
                'success' => true,
                'message' => 'Match score updated'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error updating match score: ' . $e->getMessage()
            ], 500);
        }
    }

    public function pauseMatch(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match || $match->status !== 'live') {
                return response()->json([
                    'success' => false,
                    'message' => 'Match must be live to pause'
                ], 400);
            }

            // Update match status and save current state
            $liveData = json_decode($match->live_data, true) ?? [];
            $liveData['paused_at'] = now();
            $liveData['timer_paused'] = true;
            $liveData['timer_status'] = 'paused';

            DB::table('matches')->where('id', $matchId)->update([
                'status' => 'paused',
                'live_data' => json_encode($liveData),
                'updated_at' => now()
            ]);

            // Broadcast pause event
            event(new \App\Events\MatchPaused($matchId));

            return response()->json([
                'success' => true,
                'message' => 'Match paused successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error pausing match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function resumeMatch(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match || $match->status !== 'paused') {
                return response()->json([
                    'success' => false,
                    'message' => 'Match must be paused to resume'
                ], 400);
            }

            // Update match status and restore timer
            $liveData = json_decode($match->live_data, true) ?? [];
            $liveData['resumed_at'] = now();
            $liveData['timer_paused'] = false;
            $liveData['timer_status'] = 'running';

            DB::table('matches')->where('id', $matchId)->update([
                'status' => 'live',
                'live_data' => json_encode($liveData),
                'updated_at' => now()
            ]);

            // Broadcast resume event
            event(new \App\Events\MatchResumed($matchId));

            return response()->json([
                'success' => true,
                'message' => 'Match resumed successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error resuming match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function restartMatch(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        $request->validate([
            'reason' => 'required|string',
            'reset_scores' => 'boolean',
            'reset_stats' => 'boolean'
        ]);

        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json([
                    'success' => false,
                    'message' => 'Match not found'
                ], 404);
            }

            // Reset match data based on options
            $updateData = [
                'status' => 'upcoming',
                'started_at' => null,
                'updated_at' => now()
            ];

            if ($request->reset_scores) {
                $updateData['team1_score'] = 0;
                $updateData['team2_score'] = 0;
                $updateData['series_score_team1'] = 0;
                $updateData['series_score_team2'] = 0;
                $updateData['current_map_number'] = 1;
                
                // Reset maps data
                $mapsData = json_decode($match->maps_data, true) ?? [];
                foreach ($mapsData as &$map) {
                    $map['status'] = 'not_played';
                    $map['team1_score'] = 0;
                    $map['team2_score'] = 0;
                    $map['winner_id'] = null;
                    $map['started_at'] = null;
                    $map['completed_at'] = null;
                }
                $updateData['maps_data'] = json_encode($mapsData);
            }

            if ($request->reset_stats) {
                // Delete existing player stats
                DB::table('player_match_stats')->where('match_id', $matchId)->delete();
                
                // Reset player stats JSON
                $updateData['player_stats'] = json_encode($this->initializePlayerStats($match->team1_id, $match->team2_id));
            }

            // Reset live data
            $updateData['live_data'] = json_encode($this->initializeLiveData());

            DB::table('matches')->where('id', $matchId)->update($updateData);

            // Log restart
            DB::table('match_logs')->insert([
                'match_id' => $matchId,
                'action' => 'restart',
                'reason' => $request->reason,
                'performed_by' => Auth::id(),
                'created_at' => now()
            ]);

            return response()->json([
                'success' => true,
                'message' => 'Match restarted successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error restarting match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function startMatch(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json([
                    'success' => false,
                    'message' => 'Match not found'
                ], 404);
            }

            if ($match->status !== 'upcoming') {
                return response()->json([
                    'success' => false,
                    'message' => 'Match can only be started from upcoming status'
                ], 400);
            }

            DB::table('matches')->where('id', $matchId)->update([
                'status' => 'live',
                'started_at' => now(),
                'actual_start_time' => now(),
                'current_map_number' => 1,
                'timer_running' => true,
                'updated_at' => now()
            ]);

            // Initialize first map
            $mapsData = json_decode($match->maps_data, true) ?? [];
            if (isset($mapsData[0])) {
                $mapsData[0]['status'] = 'ongoing';
                $mapsData[0]['started_at'] = now();
                
                DB::table('matches')->where('id', $matchId)->update([
                    'maps_data' => json_encode($mapsData)
                ]);
            }

            // Broadcast match started event
            event(new \App\Events\MatchStarted($matchId));

            return response()->json([
                'success' => true,
                'message' => 'Match started successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error starting match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function deleteMatch(Request $request, $matchId)
    {
        $this->authorize('manage-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json([
                    'success' => false,
                    'message' => 'Match not found'
                ], 404);
            }

            // Delete related data
            DB::table('player_match_stats')->where('match_id', $matchId)->delete();
            DB::table('match_comments')->where('match_id', $matchId)->delete();
            DB::table('match_logs')->where('match_id', $matchId)->delete();
            
            // Delete the match
            DB::table('matches')->where('id', $matchId)->delete();

            return response()->json([
                'success' => true,
                'message' => 'Match deleted successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error deleting match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function completeMatch(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            
            // Determine winner
            $winner = null;
            if ($match->team1_score > $match->team2_score) {
                $winner = $match->team1_id;
            } elseif ($match->team2_score > $match->team1_score) {
                $winner = $match->team2_id;
            }

            DB::table('matches')
                ->where('id', $matchId)
                ->update([
                    'status' => 'completed',
                    'winner_id' => $winner,
                    'completed_at' => now(),
                    'updated_at' => now()
                ]);

            // Update team ratings if applicable
            if ($winner) {
                $this->updateTeamRatings($match->team1_id, $match->team2_id, $winner);
            }

            return response()->json([
                'success' => true,
                'message' => 'Match completed successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error completing match: ' . $e->getMessage()
            ], 500);
        }
    }

    // Admin CRUD Functions
    public function getAllMatches(Request $request)
    {
        $this->authorize('manage-matches');
        
        try {
            $query = DB::table('matches as m')
                ->leftJoin('teams as t1', 'm.team1_id', '=', 't1.id')
                ->leftJoin('teams as t2', 'm.team2_id', '=', 't2.id')
                ->leftJoin('events as e', 'm.event_id', '=', 'e.id')
                ->select([
                    'm.*',
                    't1.name as team1_name', 't2.name as team2_name',
                    'e.name as event_name'
                ]);

            if ($request->search) {
                $query->where(function($q) use ($request) {
                    $q->where('t1.name', 'LIKE', "%{$request->search}%")
                      ->orWhere('t2.name', 'LIKE', "%{$request->search}%")
                      ->orWhere('e.name', 'LIKE', "%{$request->search}%");
                });
            }

            $matches = $query->orderBy('m.scheduled_at', 'desc')->paginate(20);

            return response()->json([
                'data' => $matches->items(),
                'pagination' => [
                    'current_page' => $matches->currentPage(),
                    'last_page' => $matches->lastPage(),
                    'per_page' => $matches->perPage(),
                    'total' => $matches->total()
                ],
                'success' => true
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error fetching matches: ' . $e->getMessage()
            ], 500);
        }
    }

    public function getMatchAdmin($matchId)
    {
        $this->authorize('manage-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            
            if (!$match) {
                return response()->json([
                    'success' => false,
                    'message' => 'Match not found'
                ], 404);
            }

            // Return complete match data for admin editing
            return response()->json([
                'data' => [
                    'id' => $match->id,
                    'team1_id' => $match->team1_id,
                    'team2_id' => $match->team2_id,
                    'event_id' => $match->event_id,
                    'scheduled_at' => $match->scheduled_at,
                    'format' => $match->format,
                    'status' => $match->status,
                    'team1_score' => $match->team1_score,
                    'team2_score' => $match->team2_score,
                    'current_map' => $match->current_map,
                    'stream_url' => $match->stream_url,
                    'round' => $match->round,
                    'bracket_position' => $match->bracket_position,
                    'maps_data' => json_decode($match->maps_data, true),
                    'live_data' => json_decode($match->live_data, true)
                ],
                'success' => true
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error fetching match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function destroy($matchId)
    {
        $this->authorize('manage-matches');
        
        try {
            // Delete related data first
            DB::table('player_match_stats')->where('match_id', $matchId)->delete();
            DB::table('match_comments')->where('match_id', $matchId)->delete();
            
            // Delete match
            DB::table('matches')->where('id', $matchId)->delete();
            
            return response()->json([
                'success' => true,
                'message' => 'Match deleted successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error deleting match: ' . $e->getMessage()
            ], 500);
        }
    }

    // Temporary direct match creation method (bypasses authorization)
    public function createMatchDirect(Request $request)
    {
        try {
            $request->validate([
                'team1_id' => 'required|integer|exists:teams,id',
                'team2_id' => 'required|integer|exists:teams,id|different:team1_id',
                'title' => 'nullable|string|max:255',
                'description' => 'nullable|string',
                'format' => 'required|in:BO1,BO3,BO5,BO7,BO9',
                'status' => 'required|in:upcoming,live,completed,cancelled,postponed',
                'scheduled_at' => 'nullable|date',
                'event_id' => 'nullable|integer|exists:events,id'
            ]);

            $matchData = [
                'team1_id' => $request->team1_id,
                'team2_id' => $request->team2_id,
                'title' => $request->title ?: 'Match',
                'description' => $request->description,
                'format' => $request->format,
                'status' => $request->status,
                'scheduled_at' => $request->scheduled_at ? \Carbon\Carbon::parse($request->scheduled_at)->format('Y-m-d H:i:s') : now(),
                'event_id' => $request->event_id,
                'team1_score' => 0,
                'team2_score' => 0,
                'current_map' => 1,
                'round' => 'Regular Season',
                'bracket_position' => 1,
                'created_at' => now(),
                'updated_at' => now()
            ];

            $matchId = DB::table('matches')->insertGetId($matchData);

            return response()->json([
                'success' => true,
                'message' => 'Match created successfully',
                'data' => [
                    'id' => $matchId,
                    'title' => $matchData['title'],
                    'format' => $matchData['format'],
                    'status' => $matchData['status']
                ]
            ], 201);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to create match: ' . $e->getMessage()
            ], 500);
        }
    }

    // Helper Methods
    private function formatMatchData($match, $isLive = false)
    {
        $mapsData = $match->maps_data ? json_decode($match->maps_data, true) : [];
        $liveData = $match->live_data ? json_decode($match->live_data, true) : [];

        return [
            'id' => $match->id,
            'team1' => [
                'id' => $match->team1_id,
                'name' => $match->team1_name,
                'short_name' => $match->team1_short,
                'logo' => $match->team1_logo,
                'region' => $match->team1_region,
                'rating' => $match->team1_rating ?? 1000,
                'flag' => $match->team1_flag ?? null
            ],
            'team2' => [
                'id' => $match->team2_id,
                'name' => $match->team2_name,
                'short_name' => $match->team2_short,
                'logo' => $match->team2_logo,
                'region' => $match->team2_region,
                'rating' => $match->team2_rating ?? 1000,
                'flag' => $match->team2_flag ?? null
            ],
            'event' => [
                'id' => $match->event_id,
                'name' => $match->event_name ?? 'Regular Match',
                'type' => $match->event_type ?? 'Tournament',
                'logo' => $match->event_logo ?? null
            ],
            'match_info' => [
                'scheduled_at' => $match->scheduled_at,
                'status' => $match->status,
                'format' => $match->format,
                'round' => $match->round,
                'current_map' => $match->current_map ?? 1,
                'viewers' => $match->viewers ?? 0
            ],
            'score' => [
                'team1' => $match->team1_score ?? 0,
                'team2' => $match->team2_score ?? 0,
                'maps' => $mapsData
            ],
            'broadcast' => [
                'stream' => $match->stream_url ?? null,
                'streams' => json_decode($match->stream_urls ?? '[]', true),
                'betting' => json_decode($match->betting_urls ?? '[]', true),
                'vods' => json_decode($match->vod_urls ?? '[]', true),
                'viewers' => $match->viewers ?? 0
            ],
            'live_data' => $isLive ? $liveData : null
        ];
    }

    private function getCompleteMatchData($match)
    {
        $matchData = $this->formatMatchData($match);
        
        // Get team rosters with stats
        $matchData['team1']['roster'] = $this->getTeamRosterWithStats($match->team1_id, $match->id);
        $matchData['team2']['roster'] = $this->getTeamRosterWithStats($match->team2_id, $match->id);
        
        // Get detailed map data - ENSURE CONSISTENCY WITH FRONTEND
        $mapsData = json_decode($match->maps_data, true) ?? [];
        foreach ($mapsData as $index => &$map) {
            $map['index'] = $index + 1;
            $map['player_stats'] = $this->getMapPlayerStats($match->id, $index + 1);
            
            // ENSURE CONSISTENT TEAM COMPOSITION STRUCTURE
            if (isset($map['team1_composition'])) {
                $map['team1_composition'] = array_map(function($player) {
                    return [
                        'player_id' => $player['player_id'] ?? $player['id'] ?? null,
                        'player_name' => $player['player_name'] ?? $player['name'] ?? $player['username'] ?? 'Unknown Player',
                        'name' => $player['player_name'] ?? $player['name'] ?? $player['username'] ?? 'Unknown Player',
                        'username' => $player['username'] ?? $player['player_name'] ?? $player['name'] ?? 'Unknown Player',
                        'hero' => $player['hero'] ?? 'Captain America',
                        'role' => $player['role'] ?? 'Vanguard',
                        'country' => $player['country'] ?? $player['nationality'] ?? 'US',
                        'nationality' => $player['country'] ?? $player['nationality'] ?? 'US',
                        // Stats structure
                        'eliminations' => $player['eliminations'] ?? 0,
                        'deaths' => $player['deaths'] ?? 0,
                        'assists' => $player['assists'] ?? 0,
                        'damage' => $player['damage'] ?? 0,
                        'healing' => $player['healing'] ?? 0,
                        'damage_blocked' => $player['damage_blocked'] ?? 0,
                        'ultimate_usage' => $player['ultimate_usage'] ?? 0,
                        'objective_time' => $player['objective_time'] ?? 0
                    ];
                }, $map['team1_composition']);
            }
            
            if (isset($map['team2_composition'])) {
                $map['team2_composition'] = array_map(function($player) {
                    return [
                        'player_id' => $player['player_id'] ?? $player['id'] ?? null,
                        'player_name' => $player['player_name'] ?? $player['name'] ?? $player['username'] ?? 'Unknown Player',
                        'name' => $player['player_name'] ?? $player['name'] ?? $player['username'] ?? 'Unknown Player',
                        'username' => $player['username'] ?? $player['player_name'] ?? $player['name'] ?? 'Unknown Player',
                        'hero' => $player['hero'] ?? 'Captain America',
                        'role' => $player['role'] ?? 'Vanguard',
                        'country' => $player['country'] ?? $player['nationality'] ?? 'US',
                        'nationality' => $player['country'] ?? $player['nationality'] ?? 'US',
                        // Stats structure
                        'eliminations' => $player['eliminations'] ?? 0,
                        'deaths' => $player['deaths'] ?? 0,
                        'assists' => $player['assists'] ?? 0,
                        'damage' => $player['damage'] ?? 0,
                        'healing' => $player['healing'] ?? 0,
                        'damage_blocked' => $player['damage_blocked'] ?? 0,
                        'ultimate_usage' => $player['ultimate_usage'] ?? 0,
                        'objective_time' => $player['objective_time'] ?? 0
                    ];
                }, $map['team2_composition']);
            }
        }
        
        // PROVIDE BOTH FORMATS FOR FULL COMPATIBILITY
        $matchData['maps_data'] = $mapsData;  // For LiveScoring
        $matchData['maps_detailed'] = $mapsData;  // For MatchDetail
        
        // Get match timeline
        $matchData['timeline'] = $this->getMatchTimeline($match->id);
        
        // ENHANCED: Add complete match structure for perfect synchronization
        $matchData['schedule'] = [
            'scheduled_at' => $match->scheduled_at,
            'actual_start_time' => $match->actual_start_time,
            'actual_end_time' => $match->actual_end_time,
            'timezone' => 'UTC'
        ];
        
        $matchData['urls'] = [
            'streams' => json_decode($match->stream_urls ?? '[]', true),
            'betting' => json_decode($match->betting_urls ?? '[]', true),
            'vods' => json_decode($match->vod_urls ?? '[]', true)
        ];
        
        $matchData['tournament'] = [
            'round' => $match->round,
            'bracket_position' => $match->bracket_position,
            'bracket_type' => $match->bracket_type ?? 'main'
        ];
        
        $matchData['scores'] = [
            'series' => [
                'team1' => $match->team1_score ?? 0,
                'team2' => $match->team2_score ?? 0
            ],
            'maps' => $mapsData
        ];
        
        $matchData['live_data'] = [
            'current_map' => $match->current_map_number ?? 1,
            'timer' => $match->live_timer ?? '00:00',
            'timer_running' => $match->timer_running ?? false,
            'overtime' => $match->overtime ?? false,
            'viewers' => $match->viewers ?? 0,
            'hero_picks' => json_decode($match->hero_data ?? '{}', true),
            'live_updates' => json_decode($match->live_data ?? '{}', true),
            'preparation_phase' => $match->is_preparation_phase ?? false,
            'preparation_timer' => $match->preparation_timer ?? 45
        ];
        
        $matchData['player_stats'] = json_decode($match->player_stats ?? '{}', true);
        
        // Add required fields for frontend compatibility
        $matchData['teams'] = [
            'team1' => $matchData['team1'],
            'team2' => $matchData['team2']
        ];
        
        // Ensure status is set
        $matchData['status'] = $match->status ?? 'upcoming';
        
        // Ensure format is set
        $matchData['format'] = $match->format ?? 'BO3';
        
        return $matchData;
    }

    private function getTeamRosterWithStats($teamId, $matchId)
    {
        return DB::table('players as p')
            ->leftJoin('player_match_stats as mps', function($join) use ($matchId) {
                $join->on('p.id', '=', 'mps.player_id')
                     ->where('mps.match_id', '=', $matchId);
            })
            ->where('p.team_id', $teamId)
            ->where('p.status', 'active')
            ->select([
                'p.id', 'p.username', 'p.real_name', 'p.role', 'p.avatar',
                'p.main_hero', 'p.country', 'p.nationality', 'p.age',
                DB::raw('COALESCE(SUM(mps.eliminations), 0) as total_kills'),
                DB::raw('COALESCE(SUM(mps.deaths), 0) as total_deaths'),
                DB::raw('COALESCE(SUM(mps.assists), 0) as total_assists'),
                DB::raw('COALESCE(AVG(mps.damage), 0) as avg_damage'),
                DB::raw('COALESCE(AVG(mps.healing), 0) as avg_healing'),
                DB::raw('COALESCE(AVG(mps.damage_blocked), 0) as avg_damage_blocked'),
                DB::raw('COALESCE(AVG(mps.ultimate_usage), 0) as avg_ultimate_usage'),
                DB::raw('COALESCE(AVG(mps.objective_time), 0) as avg_objective_time')
            ])
            ->groupBy('p.id', 'p.username', 'p.real_name', 'p.role', 'p.avatar', 'p.main_hero', 'p.country', 'p.nationality', 'p.age')
            ->get()
            ->map(function($player) {
                return [
                    'id' => $player->id,
                    'player_id' => $player->id,  // For consistency
                    'username' => $player->username,
                    'player_name' => $player->username,  // For consistency
                    'name' => $player->real_name ?: $player->username,  // For consistency
                    'real_name' => $player->real_name,
                    'role' => $player->role,
                    'avatar' => $player->avatar,
                    'hero' => $player->main_hero,  // For consistency
                    'main_hero' => $player->main_hero,
                    'country' => $player->country,  // For consistency
                    'nationality' => $player->country,  // For consistency
                    'country_flag' => $this->getCountryFlag($player->country),
                    'flag' => $this->getCountryFlag($player->country),  // For consistency
                    'age' => $player->age,
                    'stats' => [
                        'kills' => (int)$player->total_kills,
                        'eliminations' => (int)$player->total_kills,  // For consistency
                        'deaths' => (int)$player->total_deaths,
                        'assists' => (int)$player->total_assists,
                        'kda' => $player->total_deaths > 0 ? 
                            round(($player->total_kills + $player->total_assists) / $player->total_deaths, 2) : 
                            ($player->total_kills + $player->total_assists),
                        'kd_ratio' => $player->total_deaths > 0 ? 
                            round($player->total_kills / $player->total_deaths, 2) : 
                            $player->total_kills,
                        'avg_damage' => round($player->avg_damage),
                        'damage' => round($player->avg_damage),  // For consistency
                        'avg_healing' => round($player->avg_healing),
                        'healing' => round($player->avg_healing),  // For consistency
                        'damage_blocked' => round($player->avg_damage_blocked),
                        'ultimate_usage' => round($player->avg_ultimate_usage),
                        'objective_time' => round($player->avg_objective_time)
                    ]
                ];
            })
            ->toArray();
    }

    private function getMapPlayerStats($matchId, $mapNumber)
    {
        // First get the round_id from match_rounds table
        $mapRound = DB::table('match_rounds')
            ->where('match_id', $matchId)
            ->where('round_number', $mapNumber)
            ->first();
            
        if (!$mapRound) {
            return [];
        }
        
        return DB::table('player_match_stats as mps')
            ->leftJoin('players as p', 'mps.player_id', '=', 'p.id')
            ->where('mps.match_id', $matchId)
            ->where('mps.round_id', $mapRound->id)
            ->select([
                'p.id', 'p.username', 'p.team_id',
                'mps.hero_played', 'mps.eliminations as kills', 'mps.deaths', 'mps.assists',
                'mps.damage', 'mps.healing', 'mps.damage_blocked',
                'mps.ultimate_usage', 'mps.final_blows', 'mps.objective_time'
            ])
            ->get()
            ->groupBy('team_id')
            ->toArray();
    }

    private function getMatchTimeline($matchId)
    {
        return DB::table('match_events')
            ->where('match_id', $matchId)
            ->orderBy('timestamp')
            ->get()
            ->map(function($event) {
                return [
                    'time' => $event->timestamp ?? null,
                    'type' => $event->event_type ?? $event->type ?? 'unknown',
                    'description' => $event->description ?? '',
                    'team_id' => $event->team_id ?? null,
                    'player_id' => $event->player_id ?? null
                ];
            })
            ->toArray();
    }

    private function initializeMapsData($maps, $format = 'BO3')
    {
        // Handle null maps input
        if (!$maps || !is_array($maps)) {
            $maps = [];
        }
        
        $formatMapping = [
            'BO1' => 1, 'BO3' => 3, 'BO5' => 5, 'BO7' => 7, 'BO9' => 9
        ];
        
        $maxMaps = $formatMapping[$format] ?? 3;
        
        return array_map(function($map, $index) {
            return [
                'map_number' => $index + 1,
                'map_name' => $map['map_name'] ?? 'Tokyo 2099: Shibuya Sky',
                'mode' => $map['mode'] ?? $map['game_mode'] ?? 'Convoy',
                'game_mode' => $map['mode'] ?? $map['game_mode'] ?? 'Convoy', // Keep for backward compatibility
                'status' => $map['status'] ?? ($index === 0 ? 'upcoming' : 'not_played'),
                'team1_score' => $map['team1_score'] ?? 0,
                'team2_score' => $map['team2_score'] ?? 0,
                'team1_heroes' => $map['team1_heroes'] ?? [],
                'team2_heroes' => $map['team2_heroes'] ?? [],
                'team1_composition' => $map['team1_composition'] ?? [],
                'team2_composition' => $map['team2_composition'] ?? [],
                'duration' => $map['duration'] ?? '00:00',
                'started_at' => $map['started_at'] ?? null,
                'completed_at' => $map['completed_at'] ?? null,
                'winner_id' => $map['winner_id'] ?? null,
                'overtime' => $map['overtime'] ?? false
            ];
        }, array_slice($maps, 0, $maxMaps), array_keys(array_slice($maps, 0, $maxMaps)));
    }

    private function initializeLiveData()
    {
        return [
            'current_map_time' => '00:00',
            'timer_status' => 'stopped',
            'last_update' => now(),
            'updates' => []
        ];
    }

    private function startMapTimer($matchId, $mapNumber)
    {
        $match = DB::table('matches')->where('id', $matchId)->first();
        $mapsData = json_decode($match->maps_data, true);
        
        if (isset($mapsData[$mapNumber - 1])) {
            $mapsData[$mapNumber - 1]['started_at'] = now();
            $mapsData[$mapNumber - 1]['status'] = 'ongoing';
            
            DB::table('matches')->where('id', $matchId)->update([
                'maps_data' => json_encode($mapsData),
                'current_map' => $mapNumber
            ]);
        }
    }

    private function handleMapCompletion($matchId, $mapIndex, &$mapsData)
    {
        $mapsData[$mapIndex]['completed_at'] = now();
        $mapsData[$mapIndex]['status'] = 'completed';
        
        // Calculate map duration
        if ($mapsData[$mapIndex]['started_at']) {
            $start = \Carbon\Carbon::parse($mapsData[$mapIndex]['started_at']);
            $end = now();
            $duration = $end->diff($start);
            $mapsData[$mapIndex]['duration'] = sprintf('%02d:%02d', $duration->i, $duration->s);
        }
    }

    private function updateOverallScore($matchId)
    {
        $match = DB::table('matches')->where('id', $matchId)->first();
        $mapsData = json_decode($match->maps_data, true);
        
        $team1Score = 0;
        $team2Score = 0;
        
        foreach ($mapsData as $map) {
            if ($map['status'] === 'completed') {
                if ($map['team1_score'] > $map['team2_score']) {
                    $team1Score++;
                } elseif ($map['team2_score'] > $map['team1_score']) {
                    $team2Score++;
                }
            }
        }
        
        DB::table('matches')->where('id', $matchId)->update([
            'team1_score' => $team1Score,
            'team2_score' => $team2Score
        ]);
    }

    private function updatePlayerStats($matchId, $data)
    {
        // Get the map_id from match_rounds table
        $mapNumber = $data['map_number'] ?? 1;
        $mapRound = DB::table('match_rounds')
            ->where('match_id', $matchId)
            ->where('map_number', $mapNumber)
            ->first();
            
        if (!$mapRound) {
            return; // Map round doesn't exist yet
        }
        
        foreach ($data['players'] as $playerStats) {
            DB::table('player_match_stats')->updateOrInsert(
                [
                    'match_id' => $matchId,
                    'player_id' => $playerStats['player_id'],
                    'round_id' => $mapRound->id
                ],
                [
                    'hero_played' => $playerStats['hero_played'] ?? null,
                    'eliminations' => $playerStats['kills'] ?? 0,
                    'deaths' => $playerStats['deaths'] ?? 0,
                    'assists' => $playerStats['assists'] ?? 0,
                    'damage' => $playerStats['damage_dealt'] ?? 0,
                    'healing' => $playerStats['healing_done'] ?? 0,
                    'damage_blocked' => $playerStats['damage_blocked'] ?? 0,
                    'ultimate_usage' => $playerStats['ultimates_used'] ?? 0,
                    'final_blows' => $playerStats['final_blows'] ?? 0,
                    'objective_time' => $playerStats['objective_time'] ?? 0,
                    'accuracy_percentage' => $playerStats['accuracy_percentage'] ?? 0,
                    'critical_hits' => $playerStats['critical_hits'] ?? 0,
                    'environmental_kills' => $playerStats['environmental_kills'] ?? 0,
                    'team_damage_amplified' => $playerStats['team_damage_amplified'] ?? 0,
                    'cc_time_applied' => $playerStats['cc_time_applied'] ?? 0,
                    'hero_playtime_seconds' => $playerStats['hero_playtime_seconds'] ?? 0,
                    'role_played' => $playerStats['role_played'] ?? null,
                    'hero_switches' => isset($playerStats['hero_switches']) ? json_encode($playerStats['hero_switches']) : null,
                    'current_map' => $mapRound->map_name,
                    'updated_at' => now()
                ]
            );
        }
    }

    public function bulkUpdateStats(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        $request->validate([
            'map_number' => 'required|integer|min:1',
            'players' => 'required|array|min:1',
            'players.*.player_id' => 'required|exists:players,id',
            'players.*.hero_played' => 'nullable|string|max:255',
            'players.*.eliminations' => 'nullable|integer|min:0',
            'players.*.deaths' => 'nullable|integer|min:0',
            'players.*.assists' => 'nullable|integer|min:0',
            'players.*.damage' => 'nullable|integer|min:0',
            'players.*.healing' => 'nullable|integer|min:0',
            'players.*.damage_blocked' => 'nullable|integer|min:0',
            'players.*.final_blows' => 'nullable|integer|min:0',
            'players.*.environmental_kills' => 'nullable|integer|min:0',
            'players.*.accuracy_percentage' => 'nullable|numeric|min:0|max:100',
            'players.*.critical_hits' => 'nullable|integer|min:0',
            'players.*.ultimate_usage' => 'nullable|integer|min:0',
            'players.*.objective_time' => 'nullable|integer|min:0',
            'players.*.team_damage_amplified' => 'nullable|integer|min:0',
            'players.*.cc_time_applied' => 'nullable|integer|min:0',
            'players.*.hero_playtime_seconds' => 'nullable|integer|min:0',
            'players.*.role_played' => 'nullable|in:Vanguard,Duelist,Strategist',
            'players.*.hero_switches' => 'nullable|array'
        ]);

        try {
            // Check if match exists
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json([
                    'success' => false,
                    'message' => 'Match not found'
                ], 404);
            }

            // Get or create the round/map
            $mapNumber = $request->map_number;
            $mapRound = DB::table('match_rounds')
                ->where('match_id', $matchId)
                ->where('round_number', $mapNumber)
                ->first();
                
            if (!$mapRound) {
                // Create the round if it doesn't exist
                $mapsData = json_decode($match->maps_data, true);
                $mapIndex = $mapNumber - 1;
                
                if (!isset($mapsData[$mapIndex])) {
                    return response()->json([
                        'success' => false,
                        'message' => 'Invalid map number for this match'
                    ], 400);
                }
                
                $roundId = DB::table('match_rounds')->insertGetId([
                    'match_id' => $matchId,
                    'round_number' => $mapNumber,
                    'map_name' => $mapsData[$mapIndex]['map_name'] ?? null,
                    'game_mode' => $mapsData[$mapIndex]['game_mode'] ?? 'Domination',
                    'status' => $mapsData[$mapIndex]['status'] ?? 'upcoming',
                    'team1_score' => $mapsData[$mapIndex]['team1_score'] ?? 0,
                    'team2_score' => $mapsData[$mapIndex]['team2_score'] ?? 0,
                    'created_at' => now(),
                    'updated_at' => now()
                ]);
                
                $mapRound = (object)['id' => $roundId, 'map_name' => $mapsData[$mapIndex]['map_name'] ?? null];
            }

            // Get players by team for validation
            $team1Players = DB::table('players')->where('team_id', $match->team1_id)->pluck('id')->toArray();
            $team2Players = DB::table('players')->where('team_id', $match->team2_id)->pluck('id')->toArray();
            $allValidPlayers = array_merge($team1Players, $team2Players);

            // Prepare bulk update data
            $statsToUpdate = [];
            $timestamp = now();

            foreach ($request->players as $playerStat) {
                // Validate player belongs to one of the match teams
                if (!in_array($playerStat['player_id'], $allValidPlayers)) {
                    continue; // Skip invalid players
                }

                // Determine which team the player belongs to
                $teamId = in_array($playerStat['player_id'], $team1Players) ? $match->team1_id : $match->team2_id;

                $statsToUpdate[] = [
                    'match_id' => $matchId,
                    'player_id' => $playerStat['player_id'],
                    'round_id' => $mapRound->id,
                    'hero_played' => $playerStat['hero_played'] ?? null,
                    'eliminations' => $playerStat['eliminations'] ?? 0,
                    'deaths' => $playerStat['deaths'] ?? 0,
                    'assists' => $playerStat['assists'] ?? 0,
                    'damage' => $playerStat['damage'] ?? 0,
                    'healing' => $playerStat['healing'] ?? 0,
                    'damage_blocked' => $playerStat['damage_blocked'] ?? 0,
                    'final_blows' => $playerStat['final_blows'] ?? 0,
                    'environmental_kills' => $playerStat['environmental_kills'] ?? 0,
                    'accuracy_percentage' => $playerStat['accuracy_percentage'] ?? 0,
                    'critical_hits' => $playerStat['critical_hits'] ?? 0,
                    'ultimate_usage' => $playerStat['ultimate_usage'] ?? 0,
                    'objective_time' => $playerStat['objective_time'] ?? 0,
                    'team_damage_amplified' => $playerStat['team_damage_amplified'] ?? 0,
                    'cc_time_applied' => $playerStat['cc_time_applied'] ?? 0,
                    'hero_playtime_seconds' => $playerStat['hero_playtime_seconds'] ?? 0,
                    'role_played' => $playerStat['role_played'] ?? null,
                    'hero_switches' => isset($playerStat['hero_switches']) ? json_encode($playerStat['hero_switches']) : null,
                    'current_map' => $mapRound->map_name,
                    'created_at' => $timestamp,
                    'updated_at' => $timestamp
                ];
            }

            // Perform bulk upsert
            if (!empty($statsToUpdate)) {
                DB::transaction(function () use ($statsToUpdate, $matchId, $mapRound) {
                    // Delete existing stats for this match/round combination
                    $playerIds = array_column($statsToUpdate, 'player_id');
                    DB::table('player_match_stats')
                        ->where('match_id', $matchId)
                        ->where('round_id', $mapRound->id)
                        ->whereIn('player_id', $playerIds)
                        ->delete();

                    // Insert new stats
                    DB::table('player_match_stats')->insert($statsToUpdate);
                });

                // Update match's last updated timestamp
                DB::table('matches')->where('id', $matchId)->update(['updated_at' => $timestamp]);

                return response()->json([
                    'success' => true,
                    'message' => 'Player stats bulk updated successfully',
                    'data' => [
                        'match_id' => $matchId,
                        'map_number' => $mapNumber,
                        'players_updated' => count($statsToUpdate)
                    ]
                ]);
            } else {
                return response()->json([
                    'success' => false,
                    'message' => 'No valid player stats to update'
                ], 400);
            }

        } catch (\Exception $e) {
            \Log::error('MatchController@bulkUpdateStats error: ' . $e->getMessage() . ' at ' . $e->getFile() . ':' . $e->getLine());
            return response()->json([
                'success' => false,
                'message' => 'Error updating player stats: ' . $e->getMessage()
            ], 500);
        }
    }

    private function updateTeamRatings($team1Id, $team2Id, $winnerId)
    {
        // ELO calculation based on match result
        $team1 = DB::table('teams')->where('id', $team1Id)->first();
        $team2 = DB::table('teams')->where('id', $team2Id)->first();
        
        if (!$team1 || !$team2) {
            return;
        }
        
        $k = 32; // K-factor for rating volatility
        $expectedScore1 = 1 / (1 + pow(10, ($team2->rating - $team1->rating) / 400));
        $expectedScore2 = 1 - $expectedScore1;
        
        $actualScore1 = $winnerId == $team1Id ? 1 : 0;
        $actualScore2 = $winnerId == $team2Id ? 1 : 0;
        
        $newRating1 = round($team1->rating + $k * ($actualScore1 - $expectedScore1));
        $newRating2 = round($team2->rating + $k * ($actualScore2 - $expectedScore2));
        
        // Update team 1 stats
        $wins1 = $team1->wins ?? 0;
        $losses1 = $team1->losses ?? 0;
        if ($winnerId == $team1Id) {
            $wins1++;
        } else {
            $losses1++;
        }
        $winRate1 = $wins1 + $losses1 > 0 ? round(($wins1 / ($wins1 + $losses1)) * 100, 2) : 0;
        
        // Update team 2 stats
        $wins2 = $team2->wins ?? 0;
        $losses2 = $team2->losses ?? 0;
        if ($winnerId == $team2Id) {
            $wins2++;
        } else {
            $losses2++;
        }
        $winRate2 = $wins2 + $losses2 > 0 ? round(($wins2 / ($wins2 + $losses2)) * 100, 2) : 0;
        
        // Update team 1
        DB::table('teams')->where('id', $team1Id)->update([
            'rating' => $newRating1,
            'peak' => max($newRating1, $team1->peak ?? 0),
            'wins' => $wins1,
            'losses' => $losses1,
            'win_rate' => $winRate1,
            'record' => $wins1 . '-' . $losses1,
            'last_match' => now(),
            'updated_at' => now()
        ]);
        
        // Update team 2
        DB::table('teams')->where('id', $team2Id)->update([
            'rating' => $newRating2,
            'peak' => max($newRating2, $team2->peak ?? 0),
            'wins' => $wins2,
            'losses' => $losses2,
            'win_rate' => $winRate2,
            'record' => $wins2 . '-' . $losses2,
            'last_match' => now(),
            'updated_at' => now()
        ]);
        
        // Update all team rankings based on new ratings
        $this->updateAllTeamRanks();
    }
    
    private function updateAllTeamRanks()
    {
        // Get all teams sorted by rating
        $teams = DB::table('teams')
            ->orderBy('rating', 'desc')
            ->get();
        
        // Update ranks
        foreach ($teams as $index => $team) {
            DB::table('teams')
                ->where('id', $team->id)
                ->update(['rank' => $index + 1]);
        }
    }

    // Comments System
    public function storeComment(Request $request, $matchId)
    {
        $request->validate([
            'content' => 'required|string|min:3|max:1000',
            'parent_id' => 'nullable|exists:match_comments,id'
        ]);

        try {
            $commentId = DB::table('match_comments')->insertGetId([
                'match_id' => $matchId,
                'user_id' => Auth::id(),
                'parent_id' => $request->parent_id,
                'content' => $request->content,
                'created_at' => now(),
                'updated_at' => now()
            ]);

            // Process mentions using the new system
            $this->processMentions($request->content, $matchId, $commentId);

            return response()->json([
                'data' => ['id' => $commentId],
                'success' => true,
                'message' => 'Comment posted successfully'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error posting comment: ' . $e->getMessage()
            ], 500);
        }
    }

    private function getMatchComments($matchId)
    {
        $comments = DB::table('match_comments as mc')
            ->leftJoin('users as u', 'mc.user_id', '=', 'u.id')
            ->leftJoin('teams as t', 'u.team_flair_id', '=', 't.id')
            ->where('mc.match_id', $matchId)
            ->whereNull('mc.parent_id')
            ->select([
                'mc.*',
                'u.name as user_name', 'u.avatar', 'u.hero_flair',
                'u.show_hero_flair', 'u.show_team_flair',
                't.name as team_flair_name', 't.short_name as team_flair_short',
                't.logo as team_flair_logo'
            ])
            ->orderBy('mc.created_at', 'desc')
            ->get();

        return $comments->map(function($comment) use ($matchId) {
            return [
                'id' => $comment->id,
                'content' => $comment->content,
                'user' => $this->formatUserWithFlairs($comment),
                'votes' => $this->getCommentVotes($comment->id),
                'replies' => $this->getCommentReplies($comment->id, $matchId),
                'created_at' => $comment->created_at,
                'updated_at' => $comment->updated_at
            ];
        })->toArray();
    }

    private function getCommentReplies($parentId, $matchId)
    {
        $replies = DB::table('match_comments as mc')
            ->leftJoin('users as u', 'mc.user_id', '=', 'u.id')
            ->leftJoin('teams as t', 'u.team_flair_id', '=', 't.id')
            ->where('mc.match_id', $matchId)
            ->where('mc.parent_id', $parentId)
            ->select([
                'mc.*',
                'u.name as user_name', 'u.avatar', 'u.hero_flair',
                'u.show_hero_flair', 'u.show_team_flair',
                't.name as team_flair_name', 't.short_name as team_flair_short',
                't.logo as team_flair_logo'
            ])
            ->orderBy('mc.created_at', 'asc')
            ->get();

        return $replies->map(function($reply) use ($matchId) {
            return [
                'id' => $reply->id,
                'content' => $reply->content,
                'user' => $this->formatUserWithFlairs($reply),
                'votes' => $this->getCommentVotes($reply->id),
                'replies' => $this->getCommentReplies($reply->id, $matchId),
                'created_at' => $reply->created_at,
                'updated_at' => $reply->updated_at
            ];
        })->toArray();
    }

    private function formatUserWithFlairs($userData)
    {
        $user = [
            'id' => $userData->user_id,
            'name' => $userData->user_name,
            'avatar' => $userData->avatar
        ];

        // Add hero flair if enabled
        if ($userData->show_hero_flair && $userData->hero_flair) {
            $user['hero_flair'] = [
                'name' => $userData->hero_flair,
                'icon' => "/images/heroes/" . str_replace([' ', '&'], ['-', 'and'], strtolower($userData->hero_flair)) . ".png"
            ];
        }

        // Add team flair if enabled  
        if ($userData->show_team_flair && $userData->team_flair_name) {
            $user['team_flair'] = [
                'name' => $userData->team_flair_name,
                'short_name' => $userData->team_flair_short,
                'logo' => $userData->team_flair_logo
            ];
        }

        return $user;
    }

    private function getCommentVotes($commentId)
    {
        $upvotes = DB::table('comment_votes')
            ->where('comment_id', $commentId)
            ->where('comment_type', 'match')
            ->where('vote_type', 'upvote')
            ->count();
            
        $downvotes = DB::table('comment_votes')
            ->where('comment_id', $commentId)
            ->where('comment_type', 'match')
            ->where('vote_type', 'downvote')
            ->count();
            
        return [
            'upvotes' => $upvotes,
            'downvotes' => $downvotes,
            'total' => $upvotes - $downvotes
        ];
    }

    private function extractMentions($content)
    {
        $mentions = [];
        
        // Extract @username mentions
        preg_match_all('/@([a-zA-Z0-9_]+)/', $content, $userMatches);
        if (!empty($userMatches[1])) {
            $mentions['users'] = $userMatches[1];
        }
        
        // Extract @team:teamname mentions
        preg_match_all('/@team:([a-zA-Z0-9_\-]+)/', $content, $teamMatches);
        if (!empty($teamMatches[1])) {
            $mentions['teams'] = $teamMatches[1];
        }
        
        // Extract @player:playername mentions
        preg_match_all('/@player:([a-zA-Z0-9_\-]+)/', $content, $playerMatches);
        if (!empty($playerMatches[1])) {
            $mentions['players'] = $playerMatches[1];
        }
        
        return $mentions;
    }

    private function processMentions($content, $matchId, $commentId = null)
    {
        $mentions = $this->extractMentionsNew($content);
        
        foreach ($mentions as $mention) {
            try {
                // Determine the mentionable type and ID
                $mentionableType = $commentId ? 'match_comment' : 'match';
                $mentionableId = $commentId ?: $matchId;
                
                // Create mention record using the new structure
                Mention::updateOrCreate([
                    'mentionable_type' => $mentionableType,
                    'mentionable_id' => $mentionableId,
                    'mentioned_type' => $mention['type'],
                    'mentioned_id' => $mention['id'],
                    'mention_text' => $mention['mention_text'] ?? "@{$mention['name']}"
                ], [
                    'mentioned_by' => Auth::id(),
                    'mentioned_at' => now(),
                    'is_active' => true,
                    'context' => $this->extractMentionContext($content, $mention['mention_text'] ?? "@{$mention['name']}")
                ]);
            } catch (\Exception $e) {
                \Log::error('Error processing mention: ' . $e->getMessage());
            }
        }
    }

    private function extractMentionsNew($content)
    {
        $mentions = [];
        
        // Extract @username mentions (users)
        preg_match_all('/@([a-zA-Z0-9_]+)/', $content, $userMatches, PREG_OFFSET_CAPTURE);
        foreach ($userMatches[1] as $match) {
            $username = $match[0];
            $position = $userMatches[0][array_search($match, $userMatches[1])][1];
            
            $user = DB::table('users')->where('name', $username)->first();
            if ($user) {
                $mentionText = "@{$username}";
                $mentions[] = [
                    'type' => 'user',
                    'id' => $user->id,
                    'name' => $user->name,
                    'display_name' => $user->name,
                    'mention_text' => $mentionText,
                    'position_start' => $position,
                    'position_end' => $position + strlen($mentionText)
                ];
            }
        }

        // Extract @team:teamname mentions
        preg_match_all('/@team:([a-zA-Z0-9_]+)/', $content, $teamMatches, PREG_OFFSET_CAPTURE);
        foreach ($teamMatches[1] as $match) {
            $teamName = $match[0];
            $position = $teamMatches[0][array_search($match, $teamMatches[1])][1];
            
            $team = DB::table('teams')->where('short_name', $teamName)->first();
            if ($team) {
                $mentionText = "@team:{$teamName}";
                $mentions[] = [
                    'type' => 'team',
                    'id' => $team->id,
                    'name' => $team->short_name,
                    'display_name' => $team->name,
                    'mention_text' => $mentionText,
                    'position_start' => $position,
                    'position_end' => $position + strlen($mentionText)
                ];
            }
        }

        // Extract @player:playername mentions
        preg_match_all('/@player:([a-zA-Z0-9_]+)/', $content, $playerMatches, PREG_OFFSET_CAPTURE);
        foreach ($playerMatches[1] as $match) {
            $playerName = $match[0];
            $position = $playerMatches[0][array_search($match, $playerMatches[1])][1];
            
            $player = DB::table('players')->where('username', $playerName)->first();
            if ($player) {
                $mentionText = "@player:{$playerName}";
                $mentions[] = [
                    'type' => 'player',
                    'id' => $player->id,
                    'name' => $player->username,
                    'display_name' => $player->real_name ?? $player->username,
                    'mention_text' => $mentionText,
                    'position_start' => $position,
                    'position_end' => $position + strlen($mentionText)
                ];
            }
        }

        return $mentions;
    }

    private function extractMentionContext($content, $mentionText)
    {
        $position = strpos($content, $mentionText);
        if ($position === false) {
            return null;
        }

        // Extract 50 characters before and after the mention for context
        $contextLength = 50;
        $start = max(0, $position - $contextLength);
        $end = min(strlen($content), $position + strlen($mentionText) + $contextLength);
        
        $context = substr($content, $start, $end - $start);
        
        // Clean up context (remove excessive whitespace, etc.)
        $context = preg_replace('/\s+/', ' ', trim($context));
        
        return $context;
    }

    public function voteComment(Request $request, $commentId)
    {
        $this->authorize('vote');
        
        $request->validate([
            'vote_type' => 'required|in:upvote,downvote'
        ]);

        try {
            $userId = Auth::id();
            $voteType = $request->vote_type;

            // Get the comment to ensure it exists
            $comment = DB::table('match_comments')->where('id', $commentId)->first();
            if (!$comment) {
                return response()->json(['success' => false, 'message' => 'Comment not found'], 404);
            }

            // Check for existing vote
            $existingVote = DB::table('comment_votes')
                ->where('comment_id', $commentId)
                ->where('comment_type', 'match')
                ->where('user_id', $userId)
                ->first();

            if ($existingVote) {
                if ($existingVote->vote_type === $voteType) {
                    // Remove vote if same type
                    DB::table('comment_votes')->where('id', $existingVote->id)->delete();
                    
                    return response()->json([
                        'success' => true,
                        'message' => 'Vote removed',
                        'action' => 'removed'
                    ]);
                } else {
                    // Update vote if different type
                    DB::table('comment_votes')
                        ->where('id', $existingVote->id)
                        ->update(['vote_type' => $voteType, 'updated_at' => now()]);
                }
            } else {
                // Create new vote
                DB::table('comment_votes')->insert([
                    'comment_id' => $commentId,
                    'comment_type' => 'match',
                    'user_id' => $userId,
                    'vote_type' => $voteType,
                    'created_at' => now(),
                    'updated_at' => now()
                ]);
            }

            return response()->json([
                'success' => true,
                'message' => 'Vote recorded',
                'action' => 'voted'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error recording vote: ' . $e->getMessage()
            ], 500);
        }
    }

    // ===================================
    // COMPREHENSIVE MATCH SYSTEM HELPERS
    // ===================================

    private function initializeHeroData($format)
    {
        $formatMapping = [
            'BO1' => 1, 'BO3' => 3, 'BO5' => 5, 'BO7' => 7, 'BO9' => 9
        ];
        
        $maxMaps = $formatMapping[$format] ?? 3;
        $heroData = [];

        for ($i = 0; $i < $maxMaps; $i++) {
            $heroData[] = [
                'map_number' => $i + 1,
                'team1_heroes' => [],
                'team2_heroes' => [],
                'bans' => [
                    'team1_bans' => [],
                    'team2_bans' => []
                ],
                'pick_order' => [],
                'draft_completed' => false
            ];
        }

        return $heroData;
    }

    private function initializePlayerStats($team1Id, $team2Id)
    {
        // Get players for both teams with full details
        $team1Players = DB::table('players')->where('team_id', $team1Id)->where('status', 'active')->get();
        $team2Players = DB::table('players')->where('team_id', $team2Id)->where('status', 'active')->get();
        
        $playerStats = [];

        foreach ($team1Players as $player) {
            $playerStats[$player->id] = [
                'player_id' => $player->id,
                'team_id' => $team1Id,
                'name' => $player->username ?? $player->real_name,
                'username' => $player->username,
                'real_name' => $player->real_name,
                'role' => $player->role,
                'main_hero' => $player->main_hero ?? 'Captain America',
                'avatar' => $player->avatar,
                'country' => $player->country ?? 'US',
                'nationality' => $player->country ?? 'US',
                'flag' => $this->getCountryFlag($player->country ?? 'US'),
                'maps_played' => 0,
                'total_stats' => [
                    'eliminations' => 0,
                    'deaths' => 0,
                    'assists' => 0,
                    'damage' => 0,
                    'healing' => 0,
                    'damage_blocked' => 0,
                    'ultimate_usage' => 0,
                    'objective_time' => 0,
                    'kd_ratio' => 0.0
                ],
                'map_stats' => []
            ];
        }

        foreach ($team2Players as $player) {
            $playerStats[$player->id] = [
                'player_id' => $player->id,
                'team_id' => $team2Id,
                'name' => $player->username ?? $player->real_name,
                'username' => $player->username,
                'real_name' => $player->real_name,
                'role' => $player->role,
                'main_hero' => $player->main_hero ?? 'Captain America',
                'avatar' => $player->avatar,
                'country' => $player->country ?? 'US',
                'nationality' => $player->country ?? 'US',
                'flag' => $this->getCountryFlag($player->country ?? 'US'),
                'maps_played' => 0,
                'total_stats' => [
                    'eliminations' => 0,
                    'deaths' => 0,
                    'assists' => 0,
                    'damage' => 0,
                    'healing' => 0,
                    'damage_blocked' => 0,
                    'ultimate_usage' => 0,
                    'objective_time' => 0,
                    'kd_ratio' => 0.0
                ],
                'map_stats' => []
            ];
        }

        return $playerStats;
    }

    private function getCountryFlag($countryCode)
    {
        // Map country codes to flag URLs or emoji
        $flags = [
            'US' => '🇺🇸',
            'CA' => '🇨🇦',
            'GB' => '🇬🇧',
            'UK' => '🇬🇧',
            'FR' => '🇫🇷',
            'DE' => '🇩🇪',
            'ES' => '🇪🇸',
            'IT' => '🇮🇹',
            'JP' => '🇯🇵',
            'KR' => '🇰🇷',
            'CN' => '🇨🇳',
            'BR' => '🇧🇷',
            'MX' => '🇲🇽',
            'AU' => '🇦🇺',
            'NZ' => '🇳🇿',
            'SE' => '🇸🇪',
            'NO' => '🇳🇴',
            'DK' => '🇩🇰',
            'FI' => '🇫🇮',
            'NL' => '🇳🇱',
            'BE' => '🇧🇪',
            'PL' => '🇵🇱',
            'RU' => '🇷🇺',
            'UA' => '🇺🇦',
            'IN' => '🇮🇳',
            'AR' => '🇦🇷',
            'CL' => '🇨🇱',
            'CO' => '🇨🇴',
            'PE' => '🇵🇪',
            'VE' => '🇻🇪',
            'ZA' => '🇿🇦',
            'EG' => '🇪🇬',
            'SA' => '🇸🇦',
            'AE' => '🇦🇪',
            'IL' => '🇮🇱',
            'TR' => '🇹🇷',
            'GR' => '🇬🇷',
            'PT' => '🇵🇹',
            'IE' => '🇮🇪',
            'AT' => '🇦🇹',
            'CH' => '🇨🇭',
            'CZ' => '🇨🇿',
            'HU' => '🇭🇺',
            'RO' => '🇷🇴',
            'BG' => '🇧🇬',
            'HR' => '🇭🇷',
            'RS' => '🇷🇸',
            'SK' => '🇸🇰',
            'SI' => '🇸🇮',
            'LT' => '🇱🇹',
            'LV' => '🇱🇻',
            'EE' => '🇪🇪',
            'IS' => '🇮🇸',
            'MT' => '🇲🇹',
            'CY' => '🇨🇾',
            'LU' => '🇱🇺',
            'SG' => '🇸🇬',
            'MY' => '🇲🇾',
            'TH' => '🇹🇭',
            'ID' => '🇮🇩',
            'PH' => '🇵🇭',
            'VN' => '🇻🇳',
            'HK' => '🇭🇰',
            'TW' => '🇹🇼',
            'NP' => '🇳🇵',
            'PK' => '🇵🇰',
            'BD' => '🇧🇩',
            'LK' => '🇱🇰',
            'MM' => '🇲🇲',
            'KH' => '🇰🇭',
            'LA' => '🇱🇦',
            'MN' => '🇲🇳',
            'KZ' => '🇰🇿',
            'UZ' => '🇺🇿',
            'TM' => '🇹🇲',
            'KG' => '🇰🇬',
            'TJ' => '🇹🇯',
            'AF' => '🇦🇫',
            'IQ' => '🇮🇶',
            'IR' => '🇮🇷',
            'SY' => '🇸🇾',
            'LB' => '🇱🇧',
            'JO' => '🇯🇴',
            'PS' => '🇵🇸',
            'YE' => '🇾🇪',
            'OM' => '🇴🇲',
            'KW' => '🇰🇼',
            'QA' => '🇶🇦',
            'BH' => '🇧🇭',
            'MA' => '🇲🇦',
            'DZ' => '🇩🇿',
            'TN' => '🇹🇳',
            'LY' => '🇱🇾',
            'SD' => '🇸🇩',
            'ET' => '🇪🇹',
            'KE' => '🇰🇪',
            'UG' => '🇺🇬',
            'TZ' => '🇹🇿',
            'RW' => '🇷🇼',
            'BI' => '🇧🇮',
            'MW' => '🇲🇼',
            'MZ' => '🇲🇿',
            'ZM' => '🇿🇲',
            'ZW' => '🇿🇼',
            'BW' => '🇧🇼',
            'NA' => '🇳🇦',
            'AO' => '🇦🇴',
            'CD' => '🇨🇩',
            'CG' => '🇨🇬',
            'CM' => '🇨🇲',
            'GA' => '🇬🇦',
            'GQ' => '🇬🇶',
            'CF' => '🇨🇫',
            'TD' => '🇹🇩',
            'NG' => '🇳🇬',
            'GH' => '🇬🇭',
            'CI' => '🇨🇮',
            'BF' => '🇧🇫',
            'ML' => '🇲🇱',
            'NE' => '🇳🇪',
            'SN' => '🇸🇳',
            'GM' => '🇬🇲',
            'GW' => '🇬🇼',
            'GN' => '🇬🇳',
            'SL' => '🇸🇱',
            'LR' => '🇱🇷',
            'TG' => '🇹🇬',
            'BJ' => '🇧🇯',
            'MR' => '🇲🇷',
            'CV' => '🇨🇻',
            'SO' => '🇸🇴',
            'DJ' => '🇩🇯',
            'ER' => '🇪🇷',
            'SS' => '🇸🇸',
            'SZ' => '🇸🇿',
            'LS' => '🇱🇸',
            'MG' => '🇲🇬',
            'KM' => '🇰🇲',
            'MU' => '🇲🇺',
            'SC' => '🇸🇨',
            'RE' => '🇷🇪',
            'YT' => '🇾🇹',
            'MV' => '🇲🇻',
            'BT' => '🇧🇹',
            'TL' => '🇹🇱',
            'BN' => '🇧🇳',
            'PG' => '🇵🇬',
            'SB' => '🇸🇧',
            'VU' => '🇻🇺',
            'FJ' => '🇫🇯',
            'NC' => '🇳🇨',
            'PF' => '🇵🇫',
            'GU' => '🇬🇺',
            'WS' => '🇼🇸',
            'KI' => '🇰🇮',
            'TO' => '🇹🇴',
            'TV' => '🇹🇻',
            'NR' => '🇳🇷',
            'PW' => '🇵🇼',
            'MH' => '🇲🇭',
            'FM' => '🇫🇲',
            'JM' => '🇯🇲',
            'CU' => '🇨🇺',
            'HT' => '🇭🇹',
            'DO' => '🇩🇴',
            'PR' => '🇵🇷',
            'TT' => '🇹🇹',
            'BB' => '🇧🇧',
            'AG' => '🇦🇬',
            'DM' => '🇩🇲',
            'GD' => '🇬🇩',
            'KN' => '🇰🇳',
            'LC' => '🇱🇨',
            'VC' => '🇻🇨',
            'BS' => '🇧🇸',
            'BZ' => '🇧🇿',
            'GT' => '🇬🇹',
            'SV' => '🇸🇻',
            'HN' => '🇭🇳',
            'NI' => '🇳🇮',
            'CR' => '🇨🇷',
            'PA' => '🇵🇦',
            'EC' => '🇪🇨',
            'BO' => '🇧🇴',
            'PY' => '🇵🇾',
            'UY' => '🇺🇾',
            'GY' => '🇬🇾',
            'SR' => '🇸🇷',
            'GF' => '🇬🇫',
            'FK' => '🇫🇰'
        ];
        
        return $flags[strtoupper($countryCode)] ?? '🏳️';
    }


    // Live match update methods
    public function updateLiveScore(Request $request, $matchId)
    {
        $this->authorize('manage-matches');
        
        $request->validate([
            'map_number' => 'required|integer|min:1',
            'team1_score' => 'required|integer|min:0',
            'team2_score' => 'required|integer|min:0',
            'winner_id' => 'nullable|exists:teams,id'
        ]);

        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json(['success' => false, 'message' => 'Match not found'], 404);
            }

            $mapsData = json_decode($match->maps_data, true);
            $mapIndex = $request->map_number - 1;

            if (!isset($mapsData[$mapIndex])) {
                return response()->json(['success' => false, 'message' => 'Invalid map number'], 400);
            }

            // Update map score
            $mapsData[$mapIndex]['team1_score'] = $request->team1_score;
            $mapsData[$mapIndex]['team2_score'] = $request->team2_score;
            $mapsData[$mapIndex]['status'] = 'live';

            if ($request->winner_id) {
                $mapsData[$mapIndex]['winner_id'] = $request->winner_id;
                $mapsData[$mapIndex]['status'] = 'completed';
                $mapsData[$mapIndex]['completed_at'] = now();

                // Update series score
                $seriesScore1 = $match->series_score_team1;
                $seriesScore2 = $match->series_score_team2;
                
                if ($request->winner_id == $match->team1_id) {
                    $seriesScore1++;
                } else {
                    $seriesScore2++;
                }

                DB::table('matches')->where('id', $matchId)->update([
                    'series_score_team1' => $seriesScore1,
                    'series_score_team2' => $seriesScore2
                ]);
            }

            DB::table('matches')->where('id', $matchId)->update([
                'maps_data' => json_encode($mapsData),
                'current_map_number' => $request->map_number,
                'updated_at' => now()
            ]);

            return response()->json([
                'success' => true,
                'message' => 'Live score updated',
                'data' => [
                    'map_score' => [
                        'team1' => $request->team1_score,
                        'team2' => $request->team2_score
                    ],
                    'series_score' => [
                        'team1' => $seriesScore1 ?? $match->series_score_team1,
                        'team2' => $seriesScore2 ?? $match->series_score_team2
                    ]
                ]
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error updating live score: ' . $e->getMessage()
            ], 500);
        }
    }

    public function updateLiveTimer(Request $request, $matchId)
    {
        $this->authorize('manage-matches');
        
        $request->validate([
            'minutes' => 'required|integer|min:0|max:60',
            'seconds' => 'required|integer|min:0|max:59',
            'phase' => 'required|in:preparation,action,overtime,completed'
        ]);

        try {
            $timerData = [
                'minutes' => $request->minutes,
                'seconds' => $request->seconds,
                'phase' => $request->phase,
                'last_updated' => now()->toISOString()
            ];

            DB::table('matches')->where('id', $matchId)->update([
                'match_timer' => json_encode($timerData),
                'overtime' => $request->phase === 'overtime',
                'updated_at' => now()
            ]);

            return response()->json([
                'success' => true,
                'message' => 'Timer updated',
                'data' => $timerData
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error updating timer: ' . $e->getMessage()
            ], 500);
        }
    }

    public function updateHeroSelection(Request $request, $matchId)
    {
        $this->authorize('manage-matches');
        
        $request->validate([
            'map_number' => 'required|integer|min:1',
            'team_id' => 'required|exists:teams,id',
            'player_id' => 'required|exists:players,id',
            'hero_name' => 'required|string',
            'action' => 'required|in:pick,ban'
        ]);

        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json(['success' => false, 'message' => 'Match not found'], 404);
            }

            $heroData = json_decode($match->hero_data, true);
            $mapIndex = $request->map_number - 1;

            if (!isset($heroData[$mapIndex])) {
                return response()->json(['success' => false, 'message' => 'Invalid map number'], 400);
            }

            $teamKey = $request->team_id == $match->team1_id ? 'team1' : 'team2';

            if ($request->action === 'pick') {
                $heroData[$mapIndex][$teamKey . '_heroes'][] = [
                    'player_id' => $request->player_id,
                    'hero_name' => $request->hero_name,
                    'picked_at' => now()->toISOString()
                ];
            } else {
                $heroData[$mapIndex]['bans'][$teamKey . '_bans'][] = [
                    'hero_name' => $request->hero_name,
                    'banned_at' => now()->toISOString()
                ];
            }

            DB::table('matches')->where('id', $matchId)->update([
                'hero_data' => json_encode($heroData),
                'updated_at' => now()
            ]);

            // Broadcast the hero update event for real-time updates
            broadcast(new MatchHeroUpdated(
                $matchId,
                $request->map_number,
                $request->team_id,
                $request->player_id,
                $request->hero_name,
                $request->action,
                $heroData[$mapIndex]
            ));

            return response()->json([
                'success' => true,
                'message' => ucfirst($request->action) . ' recorded',
                'data' => $heroData[$mapIndex]
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error updating hero selection: ' . $e->getMessage()
            ], 500);
        }
    }


    private function getTeamData($teamId)
    {
        $team = DB::table('teams')->where('id', $teamId)->first();
        if (!$team) return null;

        $players = DB::table('players')->where('team_id', $teamId)->get();

        return [
            'id' => $team->id,
            'name' => $team->name,
            'short_name' => $team->short_name,
            'logo' => $team->logo,
            'country_flag' => $team->country_flag ?: $this->getCountryFlag($team->country),
            'region' => $team->region,
            'rating' => $team->rating,
            'players' => $players->map(function($player) {
                return [
                    'id' => $player->id,
                    'name' => $player->name,
                    'role' => $player->role,
                    'country' => $player->country,
                    'hero_pool' => $player->hero_pool ? explode(',', $player->hero_pool) : []
                ];
            })->toArray()
        ];
    }

    private function getEventData($eventId)
    {
        return DB::table('events')->where('id', $eventId)->first();
    }

    // New methods for enhanced live scoring

    public function transitionToNextMap(Request $request, $matchId)
    {
        $this->authorize('moderate-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match || $match->status !== 'live') {
                return response()->json([
                    'success' => false,
                    'message' => 'Match must be live to transition maps'
                ], 400);
            }

            $mapsData = json_decode($match->maps_data, true) ?? [];
            $currentMapIndex = $match->current_map_number - 1;
            
            // Complete current map
            if (isset($mapsData[$currentMapIndex])) {
                $mapsData[$currentMapIndex]['status'] = 'completed';
                $mapsData[$currentMapIndex]['completed_at'] = now();
                
                // Determine map winner
                if ($mapsData[$currentMapIndex]['team1_score'] > $mapsData[$currentMapIndex]['team2_score']) {
                    $mapsData[$currentMapIndex]['winner_id'] = $match->team1_id;
                } else {
                    $mapsData[$currentMapIndex]['winner_id'] = $match->team2_id;
                }
            }
            
            // Check if there's a next map
            $nextMapIndex = $currentMapIndex + 1;
            if ($nextMapIndex >= count($mapsData)) {
                return response()->json([
                    'success' => false,
                    'message' => 'No more maps available. Consider completing the match.'
                ], 400);
            }
            
            // Initialize next map
            $mapsData[$nextMapIndex]['status'] = 'upcoming';
            $mapsData[$nextMapIndex]['started_at'] = null;
            
            DB::table('matches')->where('id', $matchId)->update([
                'current_map_number' => $nextMapIndex + 1,
                'maps_data' => json_encode($mapsData),
                'is_preparation_phase' => true,
                'preparation_timer' => 45,
                'updated_at' => now()
            ]);
            
            // Broadcast map transition event
            event(new \App\Events\MatchMapTransition($matchId, $nextMapIndex + 1));
            
            return response()->json([
                'success' => true,
                'message' => 'Transitioned to next map',
                'data' => [
                    'current_map' => $nextMapIndex + 1,
                    'preparation_phase' => true
                ]
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error transitioning maps: ' . $e->getMessage()
            ], 500);
        }
    }

    public function startMap(Request $request, $matchId, $mapNumber)
    {
        $this->authorize('manage-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json(['success' => false, 'message' => 'Match not found'], 404);
            }

            $mapsData = json_decode($match->maps_data, true);
            $mapIndex = $mapNumber - 1;

            if (!isset($mapsData[$mapIndex])) {
                return response()->json(['success' => false, 'message' => 'Invalid map number'], 400);
            }

            // Update map status
            $mapsData[$mapIndex]['status'] = 'live';
            $mapsData[$mapIndex]['started_at'] = now()->toISOString();

            // Create match_rounds entry if needed
            $roundExists = DB::table('match_rounds')
                ->where('match_id', $matchId)
                ->where('round_number', $mapNumber)
                ->exists();

            if (!$roundExists) {
                DB::table('match_rounds')->insert([
                    'match_id' => $matchId,
                    'round_number' => $mapNumber,
                    'map_name' => $mapsData[$mapIndex]['map_name'],
                    'game_mode' => $mapsData[$mapIndex]['game_mode'],
                    'status' => 'live',
                    'team1_score' => 0,
                    'team2_score' => 0,
                    'created_at' => now(),
                    'updated_at' => now()
                ]);
            }

            DB::table('matches')->where('id', $matchId)->update([
                'maps_data' => json_encode($mapsData),
                'current_map_number' => $mapNumber,
                'status' => 'live',
                'updated_at' => now()
            ]);

            // Broadcast map start event
            event(new \App\Events\MatchMapStarted($matchId, $mapNumber, $mapsData[$mapIndex]));

            return response()->json([
                'success' => true,
                'message' => 'Map started',
                'data' => $mapsData[$mapIndex]
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error starting map: ' . $e->getMessage()
            ], 500);
        }
    }

    public function endMap(Request $request, $matchId, $mapNumber)
    {
        $this->authorize('manage-matches');
        
        $request->validate([
            'winner_id' => 'required|exists:teams,id'
        ]);

        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json(['success' => false, 'message' => 'Match not found'], 404);
            }

            $mapsData = json_decode($match->maps_data, true);
            $mapIndex = $mapNumber - 1;

            if (!isset($mapsData[$mapIndex])) {
                return response()->json(['success' => false, 'message' => 'Invalid map number'], 400);
            }

            // Update map status
            $mapsData[$mapIndex]['status'] = 'completed';
            $mapsData[$mapIndex]['completed_at'] = now()->toISOString();
            $mapsData[$mapIndex]['winner_id'] = $request->winner_id;

            // Calculate duration
            if (isset($mapsData[$mapIndex]['started_at'])) {
                $start = \Carbon\Carbon::parse($mapsData[$mapIndex]['started_at']);
                $duration = $start->diffInSeconds(now());
                $mapsData[$mapIndex]['duration'] = gmdate('H:i:s', $duration);
            }

            // Update series score
            $seriesScore1 = $match->series_score_team1;
            $seriesScore2 = $match->series_score_team2;
            
            if ($request->winner_id == $match->team1_id) {
                $seriesScore1++;
            } else {
                $seriesScore2++;
            }

            // Check if match is complete
            $format = $match->format;
            $requiredWins = [
                'BO1' => 1, 'BO3' => 2, 'BO5' => 3, 'BO7' => 4, 'BO9' => 5
            ][$format] ?? 2;

            $matchCompleted = $seriesScore1 >= $requiredWins || $seriesScore2 >= $requiredWins;

            // Update match_rounds
            DB::table('match_rounds')
                ->where('match_id', $matchId)
                ->where('round_number', $mapNumber)
                ->update([
                    'status' => 'completed',
                    'winner_id' => $request->winner_id,
                    'team1_score' => $mapsData[$mapIndex]['team1_score'],
                    'team2_score' => $mapsData[$mapIndex]['team2_score'],
                    'updated_at' => now()
                ]);

            DB::table('matches')->where('id', $matchId)->update([
                'maps_data' => json_encode($mapsData),
                'series_score_team1' => $seriesScore1,
                'series_score_team2' => $seriesScore2,
                'status' => $matchCompleted ? 'completed' : 'live',
                'winner_id' => $matchCompleted ? ($seriesScore1 > $seriesScore2 ? $match->team1_id : $match->team2_id) : null,
                'completed_at' => $matchCompleted ? now() : null,
                'updated_at' => now()
            ]);

            // Broadcast map end event
            event(new \App\Events\MatchMapEnded($matchId, $mapNumber, $request->winner_id, $matchCompleted));

            return response()->json([
                'success' => true,
                'message' => 'Map ended',
                'data' => [
                    'map' => $mapsData[$mapIndex],
                    'series_score' => [
                        'team1' => $seriesScore1,
                        'team2' => $seriesScore2
                    ],
                    'match_completed' => $matchCompleted
                ]
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error ending map: ' . $e->getMessage()
            ], 500);
        }
    }

    public function addKillEvent(Request $request, $matchId)
    {
        $this->authorize('manage-matches');
        
        $request->validate([
            'map_number' => 'required|integer|min:1',
            'killer_id' => 'required|exists:players,id',
            'victim_id' => 'required|exists:players,id',
            'hero_killer' => 'required|string',
            'hero_victim' => 'required|string',
            'weapon' => 'nullable|string',
            'headshot' => 'boolean',
            'ability_used' => 'nullable|string',
            'timestamp' => 'required|string'
        ]);

        try {
            // Create kill event
            $eventId = DB::table('match_events')->insertGetId([
                'match_id' => $matchId,
                'map_number' => $request->map_number,
                'event_type' => 'kill',
                'player_id' => $request->killer_id,
                'target_player_id' => $request->victim_id,
                'description' => json_encode([
                    'killer' => [
                        'id' => $request->killer_id,
                        'hero' => $request->hero_killer
                    ],
                    'victim' => [
                        'id' => $request->victim_id,
                        'hero' => $request->hero_victim
                    ],
                    'weapon' => $request->weapon,
                    'headshot' => $request->headshot ?? false,
                    'ability_used' => $request->ability_used
                ]),
                'timestamp' => $request->timestamp,
                'game_time_seconds' => $request->game_time ?? 0,
                'created_at' => now()
            ]);

            // Broadcast kill event for live feed
            event(new \App\Events\MatchKillEvent($matchId, $request->all()));

            return response()->json([
                'success' => true,
                'message' => 'Kill event added',
                'data' => ['event_id' => $eventId]
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error adding kill event: ' . $e->getMessage()
            ], 500);
        }
    }

    public function updateObjective(Request $request, $matchId, $mapNumber)
    {
        $this->authorize('manage-matches');
        
        $request->validate([
            'objective_type' => 'required|in:capture,payload,hybrid',
            'progress' => 'required|numeric|min:0|max:100',
            'capturing_team' => 'nullable|exists:teams,id',
            'checkpoint_reached' => 'nullable|integer',
            'time_remaining' => 'nullable|integer'
        ]);

        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json(['success' => false, 'message' => 'Match not found'], 404);
            }

            $liveData = json_decode($match->live_data, true);
            
            // Update objective data
            $liveData['objectives'][$mapNumber] = [
                'type' => $request->objective_type,
                'progress' => $request->progress,
                'capturing_team' => $request->capturing_team,
                'checkpoint' => $request->checkpoint_reached,
                'time_remaining' => $request->time_remaining,
                'last_updated' => now()->toISOString()
            ];

            DB::table('matches')->where('id', $matchId)->update([
                'live_data' => json_encode($liveData),
                'updated_at' => now()
            ]);

            // Broadcast objective update
            event(new \App\Events\MatchObjectiveUpdate($matchId, $mapNumber, $liveData['objectives'][$mapNumber]));

            return response()->json([
                'success' => true,
                'message' => 'Objective updated',
                'data' => $liveData['objectives'][$mapNumber]
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error updating objective: ' . $e->getMessage()
            ], 500);
        }
    }

    public function pauseMatch(Request $request, $matchId)
    {
        $this->authorize('manage-matches');
        
        $request->validate([
            'reason' => 'nullable|string|max:255'
        ]);

        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json(['success' => false, 'message' => 'Match not found'], 404);
            }

            $liveData = json_decode($match->live_data, true);
            $liveData['paused'] = true;
            $liveData['pause_time'] = now()->toISOString();
            $liveData['pause_reason'] = $request->reason;

            DB::table('matches')->where('id', $matchId)->update([
                'live_data' => json_encode($liveData),
                'updated_at' => now()
            ]);

            // Broadcast pause event
            event(new \App\Events\MatchPaused($matchId, $request->reason));

            return response()->json([
                'success' => true,
                'message' => 'Match paused'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error pausing match: ' . $e->getMessage()
            ], 500);
        }
    }

    public function resumeMatch(Request $request, $matchId)
    {
        $this->authorize('manage-matches');
        
        try {
            $match = DB::table('matches')->where('id', $matchId)->first();
            if (!$match) {
                return response()->json(['success' => false, 'message' => 'Match not found'], 404);
            }

            $liveData = json_decode($match->live_data, true);
            
            // Calculate pause duration
            if (isset($liveData['pause_time'])) {
                $pauseStart = \Carbon\Carbon::parse($liveData['pause_time']);
                $pauseDuration = $pauseStart->diffInSeconds(now());
                $liveData['total_pause_time'] = ($liveData['total_pause_time'] ?? 0) + $pauseDuration;
            }

            $liveData['paused'] = false;
            $liveData['resume_time'] = now()->toISOString();

            DB::table('matches')->where('id', $matchId)->update([
                'live_data' => json_encode($liveData),
                'updated_at' => now()
            ]);

            // Broadcast resume event
            event(new \App\Events\MatchResumed($matchId));

            return response()->json([
                'success' => true,
                'message' => 'Match resumed'
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error resuming match: ' . $e->getMessage()
            ], 500);
        }
    }


    public function getHeadToHead(Request $request, $team1Id, $team2Id)
    {
        try {
            $matches = DB::table('matches')
                ->where(function($query) use ($team1Id, $team2Id) {
                    $query->where('team1_id', $team1Id)->where('team2_id', $team2Id);
                })
                ->orWhere(function($query) use ($team1Id, $team2Id) {
                    $query->where('team1_id', $team2Id)->where('team2_id', $team1Id);
                })
                ->where('status', 'completed')
                ->orderBy('completed_at', 'desc')
                ->limit(10)
                ->get();

            $stats = [
                'total_matches' => $matches->count(),
                'team1_wins' => 0,
                'team2_wins' => 0,
                'recent_matches' => []
            ];

            foreach ($matches as $match) {
                if ($match->winner_id == $team1Id) {
                    $stats['team1_wins']++;
                } elseif ($match->winner_id == $team2Id) {
                    $stats['team2_wins']++;
                }

                $stats['recent_matches'][] = [
                    'id' => $match->id,
                    'date' => $match->completed_at,
                    'winner_id' => $match->winner_id,
                    'score' => [
                        'team1' => $match->team1_score,
                        'team2' => $match->team2_score
                    ]
                ];
            }

            return response()->json([
                'success' => true,
                'data' => $stats
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error fetching head to head: ' . $e->getMessage()
            ], 500);
        }
    }

    public function getComments(Request $request, $matchId)
    {
        try {
            $comments = $this->getMatchComments($matchId);
            
            return response()->json([
                'success' => true,
                'data' => $comments
            ]);

        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Error fetching comments: ' . $e->getMessage()
            ], 500);
        }
    }

    /**
     * Get country flag emoji for a given country name
     */
    private function getCountryFlag($country)
    {
        // Return country flag emoji or URL
        $flags = [
            // North America - Full names
            'United States' => '🇺🇸',
            'Canada' => '🇨🇦',
            'Mexico' => '🇲🇽',
            
            // North America - Country codes
            'US' => '🇺🇸',
            'USA' => '🇺🇸',
            'CA' => '🇨🇦',
            'MX' => '🇲🇽',
            
            // South America
            'Brazil' => '🇧🇷',
            'Argentina' => '🇦🇷',
            'Chile' => '🇨🇱',
            'Colombia' => '🇨🇴',
            'Peru' => '🇵🇪',
            'BR' => '🇧🇷',
            'AR' => '🇦🇷',
            'CL' => '🇨🇱',
            'CO' => '🇨🇴',
            'PE' => '🇵🇪',
            
            // Europe - Full names
            'United Kingdom' => '🇬🇧',
            'France' => '🇫🇷',
            'Germany' => '🇩🇪',
            'Spain' => '🇪🇸',
            'Italy' => '🇮🇹',
            'Netherlands' => '🇳🇱',
            'Sweden' => '🇸🇪',
            'Denmark' => '🇩🇰',
            'Norway' => '🇳🇴',
            'Finland' => '🇫🇮',
            'Poland' => '🇵🇱',
            'Russia' => '🇷🇺',
            'Turkey' => '🇹🇷',
            'Ukraine' => '🇺🇦',
            'Czech Republic' => '🇨🇿',
            'Portugal' => '🇵🇹',
            'Belgium' => '🇧🇪',
            'Austria' => '🇦🇹',
            'Switzerland' => '🇨🇭',
            
            // Europe - Country codes
            'EU' => '🇪🇺', // European Union flag for mixed European teams
            'GB' => '🇬🇧',
            'UK' => '🇬🇧',
            'FR' => '🇫🇷',
            'DE' => '🇩🇪',
            'ES' => '🇪🇸',
            'IT' => '🇮🇹',
            'NL' => '🇳🇱',
            'SE' => '🇸🇪',
            'DK' => '🇩🇰',
            'NO' => '🇳🇴',
            'FI' => '🇫🇮',
            'PL' => '🇵🇱',
            'RU' => '🇷🇺',
            'TR' => '🇹🇷',
            'UA' => '🇺🇦',
            'CZ' => '🇨🇿',
            'PT' => '🇵🇹',
            'BE' => '🇧🇪',
            'AT' => '🇦🇹',
            'CH' => '🇨🇭',
            
            // Asia - Full names
            'South Korea' => '🇰🇷',
            'Japan' => '🇯🇵',
            'China' => '🇨🇳',
            'Taiwan' => '🇹🇼',
            'Hong Kong' => '🇭🇰',
            'Singapore' => '🇸🇬',
            'Thailand' => '🇹🇭',
            'Malaysia' => '🇲🇾',
            'Philippines' => '🇵🇭',
            'Indonesia' => '🇮🇩',
            'Vietnam' => '🇻🇳',
            'India' => '🇮🇳',
            
            // Asia - Country codes
            'KR' => '🇰🇷',
            'JP' => '🇯🇵',
            'CN' => '🇨🇳',
            'TW' => '🇹🇼',
            'HK' => '🇭🇰',
            'SG' => '🇸🇬',
            'TH' => '🇹🇭',
            'MY' => '🇲🇾',
            'PH' => '🇵🇭',
            'ID' => '🇮🇩',
            'VN' => '🇻🇳',
            'IN' => '🇮🇳',
            
            // Oceania
            'Australia' => '🇦🇺',
            'New Zealand' => '🇳🇿',
            'AU' => '🇦🇺',
            'NZ' => '🇳🇿',
            
            // Africa
            'South Africa' => '🇿🇦',
            'ZA' => '🇿🇦',
            
            // Middle East
            'Israel' => '🇮🇱',
            'United Arab Emirates' => '🇦🇪',
            'IL' => '🇮🇱',
            'AE' => '🇦🇪',
            
            // Special cases
            'Free Agent' => '🌐',
            'International' => '🌍',
            'Unknown' => '❓'
        ];
        
        return $flags[$country] ?? '🌍';
    }

    /**
     * Comprehensive live control endpoint for match updates
     */
    public function liveControl(Request $request, $matchId)
    {
        $match = DB::table('matches')->where('id', $matchId)->first();
        if (!$match) {
            return response()->json(['error' => 'Match not found'], 404);
        }

        $action = $request->input('action');
        
        switch ($action) {
            case 'update_scores':
                return $this->handleScoreUpdate($request, $match);
                
            case 'update_composition':
                return $this->handleCompositionUpdate($request, $match);
                
            case 'update_player_stats':
                return $this->handlePlayerStatsUpdate($request, $match);
                
            case 'hero_switch':
                return $this->handleHeroSwitch($request, $match);
                
            case 'pause':
                return $this->pauseMatch(new Request(), $matchId);
                
            case 'resume':
                return $this->resumeMatch(new Request(), $matchId);
                
            default:
                return response()->json(['error' => 'Invalid action'], 400);
        }
    }

    private function handleScoreUpdate($request, $match)
    {
        $mapNumber = $request->input('map_number', 1);
        $teamScores = $request->input('team_scores');
        
        // Update map data
        $mapsData = json_decode($match->maps_data ?? '[]', true);
        if (!isset($mapsData[$mapNumber - 1])) {
            $mapsData[$mapNumber - 1] = [];
        }
        
        $mapsData[$mapNumber - 1]['team1_score'] = $teamScores['team1'] ?? 0;
        $mapsData[$mapNumber - 1]['team2_score'] = $teamScores['team2'] ?? 0;
        
        // Determine map winner
        if ($mapsData[$mapNumber - 1]['team1_score'] > $mapsData[$mapNumber - 1]['team2_score']) {
            $mapsData[$mapNumber - 1]['winner_id'] = $match->team1_id;
        } elseif ($mapsData[$mapNumber - 1]['team2_score'] > $mapsData[$mapNumber - 1]['team1_score']) {
            $mapsData[$mapNumber - 1]['winner_id'] = $match->team2_id;
        }
        
        // Update match scores
        $team1Score = 0;
        $team2Score = 0;
        foreach ($mapsData as $map) {
            if (isset($map['winner_id'])) {
                if ($map['winner_id'] == $match->team1_id) {
                    $team1Score++;
                } elseif ($map['winner_id'] == $match->team2_id) {
                    $team2Score++;
                }
            }
        }
        
        DB::table('matches')->where('id', $match->id)->update([
            'maps_data' => json_encode($mapsData),
            'team1_score' => $team1Score,
            'team2_score' => $team2Score,
            'updated_at' => now()
        ]);
        
        // Broadcast update
        $winnerId = $mapsData[$mapNumber - 1]['winner_id'] ?? null;
        
        // Check if match is completed (determine max maps needed to win)
        $maxMaps = (int)str_replace(['BO', 'bo'], '', $match->format ?? 'BO3');
        $mapsToWin = intval(($maxMaps + 1) / 2);
        $matchCompleted = ($team1Score >= $mapsToWin || $team2Score >= $mapsToWin);
        
        broadcast(new \App\Events\MatchMapEnded($match->id, $mapNumber, $winnerId, $matchCompleted));
        
        return response()->json(['success' => true, 'maps_data' => $mapsData]);
    }

    private function handleCompositionUpdate($request, $match)
    {
        $mapNumber = $request->input('map_number', 1);
        $playerStats = $request->input('player_stats', []);
        
        // Update map compositions
        $mapsData = json_decode($match->maps_data ?? '[]', true);
        if (!isset($mapsData[$mapNumber - 1])) {
            $mapsData[$mapNumber - 1] = [];
        }
        
        $team1Composition = [];
        $team2Composition = [];
        
        foreach ($playerStats as $stat) {
            $playerId = $stat['player_id'];
            $hero = $stat['hero'];
            
            // Get player's team
            $player = DB::table('players')->where('id', $playerId)->first();
            if ($player) {
                if ($player->team_id == $match->team1_id) {
                    $team1Composition[] = ['player_id' => $playerId, 'hero' => $hero];
                } elseif ($player->team_id == $match->team2_id) {
                    $team2Composition[] = ['player_id' => $playerId, 'hero' => $hero];
                }
            }
        }
        
        $mapsData[$mapNumber - 1]['team1_composition'] = $team1Composition;
        $mapsData[$mapNumber - 1]['team2_composition'] = $team2Composition;
        
        DB::table('matches')->where('id', $match->id)->update([
            'maps_data' => json_encode($mapsData),
            'updated_at' => now()
        ]);
        
        // Also update player stats
        foreach ($playerStats as $stat) {
            DB::table('player_match_stats')->updateOrInsert(
                [
                    'match_id' => $match->id,
                    'player_id' => $stat['player_id'],
                    'round_id' => $mapNumber
                ],
                [
                    'hero_played' => $stat['hero'],
                    'eliminations' => $stat['eliminations'] ?? 0,
                    'deaths' => $stat['deaths'] ?? 0,
                    'assists' => $stat['assists'] ?? 0,
                    'damage' => $stat['damage'] ?? 0,
                    'healing' => $stat['healing'] ?? 0,
                    'damage_blocked' => $stat['blocked'] ?? 0,
                    'updated_at' => now()
                ]
            );
        }
        
        return response()->json(['success' => true]);
    }

    private function handlePlayerStatsUpdate($request, $match)
    {
        // This is handled in handleCompositionUpdate
        return $this->handleCompositionUpdate($request, $match);
    }

    private function handleHeroSwitch($request, $match)
    {
        $playerId = $request->input('player_id');
        $newHero = $request->input('hero');
        $mapNumber = $request->input('map_number', 1);
        
        // Update in maps_data
        $mapsData = json_decode($match->maps_data ?? '[]', true);
        if (isset($mapsData[$mapNumber - 1])) {
            // Update team1 composition
            if (isset($mapsData[$mapNumber - 1]['team1_composition'])) {
                foreach ($mapsData[$mapNumber - 1]['team1_composition'] as &$comp) {
                    if ($comp['player_id'] == $playerId) {
                        $comp['hero'] = $newHero;
                        break;
                    }
                }
            }
            // Update team2 composition  
            if (isset($mapsData[$mapNumber - 1]['team2_composition'])) {
                foreach ($mapsData[$mapNumber - 1]['team2_composition'] as &$comp) {
                    if ($comp['player_id'] == $playerId) {
                        $comp['hero'] = $newHero;
                        break;
                    }
                }
            }
        }
        
        DB::table('matches')->where('id', $match->id)->update([
            'maps_data' => json_encode($mapsData),
            'updated_at' => now()
        ]);
        
        // Broadcast hero update
        broadcast(new \App\Events\MatchHeroUpdated($match->id, $playerId, $newHero));
        
        return response()->json(['success' => true]);
    }
}