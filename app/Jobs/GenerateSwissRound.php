<?php

namespace App\Jobs;

use App\Models\BracketStage;
use App\Services\TournamentIntegrationService;
use App\Events\BracketUpdated;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class GenerateSwissRound implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public $timeout = 120; // 2 minutes timeout
    public $tries = 2;

    protected BracketStage $stage;
    protected int $roundNumber;
    protected bool $autoGenerated;

    public function __construct(BracketStage $stage, int $roundNumber, bool $autoGenerated = false)
    {
        $this->stage = $stage;
        $this->roundNumber = $roundNumber;
        $this->autoGenerated = $autoGenerated;
        
        // Use normal queue for Swiss round generation
        $this->onQueue('tournaments');
    }

    public function handle(TournamentIntegrationService $tournamentService): void
    {
        try {
            Log::info('Generating Swiss round', [
                'stage_id' => $this->stage->id,
                'round_number' => $this->roundNumber,
                'auto_generated' => $this->autoGenerated,
                'tournament_id' => $this->stage->tournament_id,
                'event_id' => $this->stage->event_id
            ]);

            // Cache generation status
            $cacheKey = "swiss_generation_{$this->stage->id}_round_{$this->roundNumber}";
            Cache::put($cacheKey, [
                'status' => 'processing',
                'started_at' => now(),
                'round_number' => $this->roundNumber
            ], 300);

            // Generate Swiss round pairings
            $matches = $tournamentService->generateSwissRound($this->stage, $this->roundNumber);

            // Update stage current round
            $this->stage->update([
                'current_round' => $this->roundNumber,
                'status' => 'active'
            ]);

            // Generate Liquipedia notation for the new round
            $liquipediaNotation = $this->generateRoundNotation($matches);

            // Cache successful completion
            $result = [
                'status' => 'completed',
                'completed_at' => now(),
                'matches_created' => $matches->count(),
                'round_number' => $this->roundNumber,
                'matches' => $matches->toArray(),
                'liquipedia_notation' => $liquipediaNotation
            ];

            Cache::put($cacheKey, $result, 3600);

            // Cache for SSE updates
            $this->cacheSSEUpdate($result);

            // Broadcast the update
            $this->broadcastRoundGenerated($matches, $liquipediaNotation);

            Log::info('Swiss round generated successfully', [
                'stage_id' => $this->stage->id,
                'round_number' => $this->roundNumber,
                'matches_created' => $matches->count(),
                'execution_time' => microtime(true) - LARAVEL_START
            ]);

        } catch (\Exception $e) {
            Log::error('Swiss round generation failed', [
                'stage_id' => $this->stage->id,
                'round_number' => $this->roundNumber,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            // Cache failure
            Cache::put($cacheKey, [
                'status' => 'failed',
                'failed_at' => now(),
                'error' => $e->getMessage(),
                'round_number' => $this->roundNumber
            ], 3600);

            throw $e;
        }
    }

    protected function generateRoundNotation($matches): array
    {
        return $matches->map(function ($match, $index) {
            return [
                'liquipedia_id' => "R{$this->roundNumber}M" . ($index + 1),
                'match_id' => $match->match_id,
                'teams' => [
                    'team1' => $match->team1 ? [
                        'id' => $match->team1->id,
                        'name' => $match->team1->name,
                        'short_name' => $match->team1->short_name
                    ] : null,
                    'team2' => $match->team2 ? [
                        'id' => $match->team2->id,
                        'name' => $match->team2->name,
                        'short_name' => $match->team2->short_name
                    ] : null
                ],
                'pairing_info' => [
                    'team1_record' => $match->team1_source,
                    'team2_record' => $match->team2_source
                ]
            ];
        })->toArray();
    }

    protected function cacheSSEUpdate(array $result): void
    {
        $updateData = [
            'type' => 'swiss_round_generated',
            'timestamp' => now()->toISOString(),
            'data' => [
                'stage_id' => $this->stage->id,
                'stage_name' => $this->stage->name,
                'round_number' => $this->roundNumber,
                'matches_created' => $result['matches_created'],
                'auto_generated' => $this->autoGenerated,
                'liquipedia_notation' => $result['liquipedia_notation']
            ]
        ];

        // Cache for event-level updates
        if ($this->stage->event_id) {
            $cacheKey = "live_update_event_{$this->stage->event_id}_swiss_round_generated";
            Cache::put($cacheKey, $updateData, 300);
        }

        // Cache for tournament-level updates
        if ($this->stage->tournament_id) {
            $cacheKey = "live_update_tournament_{$this->stage->tournament_id}_swiss_round_generated";
            Cache::put($cacheKey, $updateData, 300);
        }

        // Cache for bracket-level updates
        $cacheKey = "live_update_bracket_{$this->stage->id}_swiss_round_generated";
        Cache::put($cacheKey, $updateData, 300);
    }

    protected function broadcastRoundGenerated($matches, array $liquipediaNotation): void
    {
        // For each match, broadcast a bracket updated event
        foreach ($matches as $match) {
            event(new BracketUpdated($match, [
                'type' => 'swiss_round_generated',
                'round_number' => $this->roundNumber,
                'auto_generated' => $this->autoGenerated
            ]));
        }
    }

    public function failed(\Throwable $exception): void
    {
        Log::error('Swiss round generation job failed permanently', [
            'stage_id' => $this->stage->id,
            'round_number' => $this->roundNumber,
            'attempts' => $this->attempts,
            'exception' => $exception->getMessage()
        ]);

        // Cache permanent failure for admin notification
        $cacheKey = "swiss_generation_failed_{$this->stage->id}_round_{$this->roundNumber}";
        Cache::put($cacheKey, [
            'status' => 'failed_permanently',
            'failed_at' => now(),
            'error' => $exception->getMessage(),
            'round_number' => $this->roundNumber,
            'requires_manual_intervention' => true
        ], 86400); // 24 hours
    }
}